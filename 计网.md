# 1.基础

## 1.1TCP/IP模型

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="img" style="zoom: 33%;" /><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img" style="zoom:50%;" />

- 应用层

  最上层的 

  将应用数据接受或传输给下一层 （传输层）

  并专注为用户提供应用功能， HTTP FTP Telnet DNS等

- 传输层

  专门为了服务应用层，称为应用间传输媒介， 实际传输功能交给网络层

  遵循两个传输协议： TCP UDP

  - TCP

    传输控制协议（Transmission Control Protocol）
    最为常用的传输层协议 ， 比如HTTP应用层协议

    特性： 流量控制 超时重传 拥塞控制等， better than UDP

  - UDP

    比较简单  只负责传送，不保证是否抵达对方  ---> 效率高

    如果要实现可靠的传输， 将TCP特性在应用层上实现就可以

  传输过程：

  - TCP Segment

    可能会有传输数据非常大的可能， 若数据包大小超过MSS（maximum segment size) （TCP最大报文段长度）

    ​	就需要将数据包分块，这样可以分治，在某一块出问题重发该块（Segment）即可，不必重发整个数据包

  - 端口（Port）

    一个设备中为了区别多个应用的接受和传输数据  需要用一个编号来标记， --->端口 （内嵌在报文中）

    80端口for web server

    22端口for 运城登录服务器

    对于浏览器（客户端）中每个小窗口 即为一个独立进程， 操作系统会为这些进程分配临时端口号

  

- 网络层

  最常使用的协议： IP协议（Internet Protocol）

  - IP

    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="img" style="zoom: 50%;" />

    将传输层的报文作为数据部分  加上IP包头组成IP报文 

  - MTU

     最大容量为MTU（Maximum Transmission Unit)

  - IP地址

    为了区分多个设备， 我们用IP地址给设备进行编号

     （对于IPV4  一共32位 分成四段 如192.168.100.1（四段，每段8位 0 - 255））

    为了简便搜索和匹配过程， 我们将IP地址分为2种意义：网络号和主机号

    - 网络号  负责标识该IP地址属于哪个【子网】的

    - 主机号  负责标识同一【子网】下的不同主机

    - 子网掩码： 计算IP的网络号和主机号

      比如IP地址 10.100.122.0/24 

      【/24】即为子网掩码（翻译成255.255.255.0：因为前面一共24个1 ----3 * 8 ）

    - 解码过程

      IP地址与子网掩码进行一个 & 操作， 即可得到【网络号】

       		此时例子中网络号 ： 10.100.122.0

      将子网掩码取反后 与 IP地址进行 & 操作， 得到【主机号】

      ​		此时例子中主机号 ：   0.0.0.0

  - 路由

    IP协议中重要能力 

    通过很多网关、路由器、交换机、等网络设备连接起来的，

    当数据包到达一个网络节点， 就通过【网络算法】决定下一步该走的路径

    - 路由器寻址：

      找到目标地址的子网，将数据包传输到对应网络中

- 网络接口层

  MAC头部 ： 包含接收方和发送方的MAC地址信息

  通过ARP协议获取对方的MAC地址

## 1.2网页传输

### ① HTTP

- 解析URL

  确认Web服务器和文件名

  （URL构成如下：）

  - http: 开头表示访问数据的协议 + //
  - Web服务器 + /
  - 目录名 + /  （可嵌套 也可省略）

  ![image-20220629095100585](C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220629095100585.png)

  在web端的文件路径

  <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220629105059018.png" alt="image-20220629105059018" style="zoom:50%;" />

  如果URL的文件指定部分省略（即无路径名） 时：

  ​		则访问根目录下的【默认文件】 （/indx.html  或 .default.html)

- 产生HTTP请求信息

  仅仅产生了消息，下一步是确认传输对象

  ![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)



### ②DNS 真实地址查询

查询服务器域名对应的IP地址（类似通过名字查电话号码， DNS服务器则是电话簿）

- 域名组成：

​			在域名中越 **往右** 层级 **越高**（按照外国人的思维 先说小的，（街道） 再说大的（省市））

- e.g : www.server.com

  - 根 DNS 服务器（.）
  - 顶级域 DNS 服务器（.com）
  - 权威 DNS 服务器（server.com）

  跟域的DNS服务器信息 保存在互联网所有DNS服务器中 

  这样客户端只要找到Any one DNS server in the internet 就可以找到目标根域DNS server through it再一路顺藤摸瓜找到下层的某台目标服务器。

- 域名解析流程

  - 客户端发出DNS请求， 问www.server.com 的IP是多少 发给本地DNS服务器（客户端TCP/IP设置中写的DNS服务器地址）

  - 本地的DNS服务器收到请求后

    ​	如果缓存里有www.server.com

    ​			则直接返回其IP

    ​	else 

    ​			去根域名服务器请求

  - 根DNS收到本地DNS请求后

    发给本地DNS    .com顶级域名服务器地址

  - 本地DNS继续向.com DNS服务器发送请求

  - .com DNS服务器 找到www.server.com 的权威DNS服务器 给本地DNS

  - 本地DNS向权威DNS服务器询问

  - 权威DNS服务器查询后将对应地址告诉本地DNS

  - 最后  本地DSNS将IP地址传给客户端  完成连接

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" alt="域名解析的工作流程" style="zoom:50%;" />

  - 缓存：

    为了节省寻址时间，在每次寻址结束后，都会备份IP地址在缓存里，寻址的缓存优先级依次为

    - 浏览器本身缓存
    - 操作系统缓存
    - hosts文件

    都没有才会去找DNS服务器

    

### ③协议栈

负责HTTP内容的传输工作

栈中上下关系有一定规则的， 上面部分给下面部分委托工作， 下面部分接受并执行

下面是整个工作的层级关系  和 协议栈内部的层级关系

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="img" style="zoom:50%;" />

- 栈的组成

  - 第一层： UDP TCP

    负责接受应用层的委托执行收发数据的操作

  - 第二层 IP

    负责网络包的手法操作

    * ICMP  告知网络包在传输过程中的产生的错误和各种错误
    * ARP    根据IP查询以太网的MAC地址

- 工作流程

  - 浏览器调用socket库 委托协议栈工作
  - 协议栈先通过UDP TCP对数据进行收发工作
  - 通过IP协议控制网络包
  - 网卡驱动负责控制网卡
  - 网卡负责完成实际的收发工作（网线中的信号执行发送和接受操作）

### ④可靠传输TCP

- TCP包头格式

  （以下为HTTP数据版本， 如果更general 一些，则把HTTP报文改为数据板块即可）

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg" alt="TCP 层报文" style="zoom:50%;" />

  【序号】：解决包乱序的问题

  【确认号】：目的确认发出去对方事发后收到。如果没有收到就重新发送，直到送达

  【状态位】： 有些带状态位的包的发送，会引起双方的状态改变

  - SYN： 发起一个连接
  - ACK： 回复
  - RST： 重新连接
  - FIN： 结束连接

  【窗口大小】：（缓存大小） 标识自己当前能够处理信息的能力

  ​							目的：做到流量控制（刚刚好，别太多，别太少， 根据缓存大小）

  

- 传输过程

  - 三次握手

    （传输数据之前） 需要TCP建立连接 between 客户端 and 服务端

    - 一开始 客户端服务端都处于`closed`状态
    - 服务端主动监听某个端口  处于`Listen` 状态
    - 客户端主动发起连接SYN， 处于`SYN-Sent`状态
    - 服务端收到连接请求， ①返回SYN，②并且ACK客户端的`SYN` 处于 `SYN-RCVD`状态
    - 客户端收到服务端的SYN和ACK后 发送对SYN确认的ACK 之后处于`ESTABLISHED`状态
    - 服务端收到ACK的ACK后 处于`ESTABLISHED`状态
    
    所以三次握手的目的 **保证双方都有发送和接受的能力**
    
  - TCP分割数据‘
  
    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg" alt="MTU 与 MSS" style="zoom:67%;" />
  
    如果HTTP请求信息过长 超出【MSS】长度 这时TCP需要把请求数据拆解成一个个数据块发送
  
    并在每一个数据块添加TCP头部
  
    再往后就都一样 添加IP头部 MAC头部
  
  - TCP报文生成
  
    协议中有2个端口 
  
    ①浏览器监听端口（随机产生）
  
    ②Web服务器监听端口（HTTP默认 80， HTTPS默认443）
  
    - 报文组成
  
      HTTP头部+ 数据



### ⑤远程定位IP

Iternet Protocol address

每一个网络 每一个主机都有一个唯一的逻辑地址

（用来与物理地址相区分）

- IP包头格式

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg" alt="IP 包头格式" style="zoom:50%;" />

  因为数据（HTTP）是经过TCP传输的，所以在IP包头的协议号， 要填写为【06】（十六进制） 表示协议为TCP

  【源IP】 客户端输出IP

  【目标IP】 通过DNS得到的Web 服务器IP

  - 客户端多个网卡情况（多个IP）

    通过路由表规则 判断哪一块网卡作为source IP

    <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220630110220982.png" alt="image-20220630110220982" style="zoom:67%;" />

    比如web 服务器IP（目标IP）为196.168.10.200

    ①先与子网掩码（Genmask）求&  得到网络号 ： 192.168.10.0 

    ②与路由表中的Destination匹配 （图中得到 为第二排， 对应的Iface 为eth1）

    所以最终得到的source IP为eth1

    【默认网关】

    在图中为第三排 Destination 和Genmask都为0

    就是当所有其他条目都无法匹配，就会自动匹配这一行，并把包发给路由器（Gateway即路由器的IP第地址）

- IP报文生成

  source IP

  Destination IP

  协议（Protocol） 为0x06

### ⑥两点传输MAC

Media Access Control address 

可以称为局域网地址，

- MAC包头格式

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg" alt="MAC 包头格式" style="zoom:50%;" />

  一般在TCP/IP通信中 MAC包头的Protocol 类型只有

  - 0x  0800： IP协议
  - 0x  0806： ARP协议

  发送方：读取网卡ROM里的存储的自己的MAC地址即可

  接收方：

  - 查询【路由表】  在表中找到相匹配的条目， 把包发给Gateway列的IP地址
  - 根据IP找到MAC地址
  - ARP协议：
    - 在ARP缓存内查询是否有对应的MAC地址
    - 在Internet中发出广播寻址

- 生成MAC报文

  至此 网络包总览如下：

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg" alt="MAC 层报文" style="zoom:50%;" />



### ⑦出口 网卡

目的： 将数字信息转换为电信号

操作：网卡

控制：网卡驱动

过程：

- 复制网络包到网卡的Cache中
- 在开头加上报头和起始帧分界符
- 末尾加上用于错误检测的帧校验序列 （Failure Censor Sequence）

### ⑧交换机

仅仅在MAC层进行操作

基于以太网设计的（俗称二层网络设备）  端口不具备MAC地址

- 包接收

  - 电信号到达网线接口  交换机里模块进行接受  

  - 模块将电信号转换为数字信号

  - 通过包末尾的【FCS】校验错误  没错则放到缓冲区（buffer）

    - 交换机端口不核对接收方MAC地址 而是直接把接受的所有网包都放入buffer
    - 判断接收方MAC地址的功能在网卡上
    - 交换机端口不具有MAC地址

  - 查询这个包的接收方MAC地址是否在【MAC表】中有记录 并发送到对应端口

    - 【MAC表】

      - 设备的MAC地址
      - 该设备连接在哪个端口上

      有多行数据

      <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220630113917116.png" alt="image-20220630113917116" style="zoom:53%;" />

    - 【MAC表】中五对应的MAC地址时

      ①将包转发到除了source Port的**全部端口**上

      （因为以太网的设计本来就是将包发送到整个网络的，然后**只有相应的接收者才接收包，而其他设备则会忽略这个包**。）

      ②如果接收到了响应包（对应端口接受了网包并向交换机回应响应包）

      ​	则会将他的MAC地址写入MAC地址表，以更新



### ⑧出境大门 路由器

经过交换机后 到达了路由器

* 路由器基本原理

  基于IP设计的 （三层网络设备）

  每个端口都有MAC地址和IP地址

  MAC地址：所以可以作为Internet的发送方和接收方

  IP地址：     同时有这2个地址从这个意义上说，与PC的网卡是一样的

  - 转发包

    路由器端口接收发给自己的Internet 网包，

     由路由表查询转发目

    向对应端口作为发送方将Internet 网包发送出去

* 包接受操作

  路由器中的一模块将端口的电信号转换为数字信号   并通过包末尾的【FCS】校验错误

  没错误就检查MAC头部的接收方MAC地址是否是自己

  （ **每一个路由器端口都有自己的MAC地址**）  

  是自己的就将其放入buffer

  else 丢弃

* 查询路由表确认输出端口

  与上面的IP处的路由表操作一样

  如果找不到匹配路由时，就会选择默认路由（Genmask = 0.0.0.0 的记录）

* 发送包操作

  ①根据路由表中的【网关列】（Gateway）判断对方的IP地址

  - IP 说明 **还没抵达终点** 还需路由器转发
  - 空  说明已经到达终点 已经找到了IP包头里的目标地址

  ②通过【ARP】协议 查询MAC地址  ，将结果作为接收方的MAC地址

  ③生成新的MAC头部

  修改发送方的地址字段为 路由器的输出端口MAC

  修改协议字段为0x 0800（IP 协议）

  ④将其转换为电信号通过端口发送

  ⑤通过交换机到达下一个路由器

**过程中 Source IP 和Destination IP永恒不变， 只有MAC地址在变**

### ⑨扒皮过程， 服务端和客户端

服务器：

- 先匹配MAC头部

- 匹配IP头部

  - 匹配IP地址
  - 查看上层协议 （一般为TCP）

- 根据上层协议匹配（匹配TCP头部）

  - 匹配序列号

    如果是需要的就放入buffer 然后返回一个【ACK】

    else 就丢弃

  - 端口号

    HTTP的服务器正在监听这个端口号

    将包发给HTTP进程

- 服务器的HTTP进程

  看到请求内容

  如果是请求访问一个页面 那么就会把网页封装在 HTTP响应报文里

  擦换啊很难过TCP IP MAC头部 发往客户端

  （经过网卡  交换机  路由器  路由器。。。 交换机， 网卡）

- 客户端

  扒皮 只剩下HTTP响应报文后 交给浏览器去渲染页面

  离开  向服务器发起TCP四次挥手  

  连接断开



# 2.HTTP

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg" alt="HTTP 的消息格式" style="zoom:33%;" />

## 2.1 基本概念

超文本传输协议（HyperText Transfer Protocol)

在计算机世界里在 【两点】之间【传输】【超文本】数据的【Protocol】

（判断 ： HTTP用于INTERNET Server ---> Local Server 【×】 cuz：可以是两点之间"INTERNET Server  <----> Local Server"

- Protocol

  确认各种控制和错误处理方式 的 **行为约定和规范**；

- transfer

  HTTP是一个**双向协议 **   **两点之间传输数据**的约定和规范

  - 基本过程

    浏览器（客户端） 向百度网站（服务端） 申请一个数据访问请求，

    服务端将数据返回给浏览器

    浏览器进行渲染在屏幕上

  - 中转与接力

    只要中间人遵循 HTTP 协议， 不打扰基本的额数据传输

    **就可以任意添加额外的东西**

- HyperText

  - 文本：

    目前已经可以扩展为 图片， 视频， 压缩包等

  - 超文本

    文字图片视频的混合体  **最关键有超链接** 从一个dd超文本跳到另外一个超文本

    （E.g: HTML ： 本身只是纯文字文件， 但是内部有很多标签定义的图片视频的LINK， 

    ​			经过浏览器的解释和渲染，就可以获得一个有文字和图片的网页了）



### 2.1.1 HTTP 状态码

| 具体含义                                                     | 常见状态        |
| ------------------------------------------------------------ | --------------- |
| 1** ： 提示， 目前处于中间态，还需后续操作                   |                 |
| 2**：  成功， 报文已被成功收到并处理                         | 200 204 206     |
| 3**：   重定向，资源位置发生变动，需要客户端重新发送请求（like ？ABORT） | 301 302 304     |
| 4**：   客户端错误，请求报文有误， Server 无法处理           | 400 403 404     |
| 5**：  服务器错误，在处理请求时发生错误                      | 500 501 502 503 |

- 1** 应用较少
- 2** 成功处理客户端的请求
  - 【200 OK】 一切正常 且返回的响应头有body数据
  - 【204 No Content】 与200相同，但是没有body数据
  - 【206 Partial Content】 应用于HTTP **分块** 下载和断电传输， 表示一部分ok
- 3**  redirection
- 4** error context  from client is wrong;
  - 400 bad request
  - 403 forbidden
  - 404 Not Found

- 5** error in web server

​	

### 2.1.2常见字段

- Host

  指定服务器的域名

  [e.g] : www.A.com

- COntent--Length

  回应数据的长度（一般单位为Byte）

  [e.g] : 1000

- Connection

  连接状态（HTTP/1.1 版本默认都是持久连接）

  为了兼容老版本的HTTP 

  ```http
  Connection: keep-alive	
  ```

  可复用的TCP连接，Till 客户端or 服务端主动关闭连接， **这不是标准字段**

- Content Type

  ```http
  Content-Type: text/html; charset=utf-8
  ```

  发送的是网页

  编码为UTF-8

  

  客户端请求时，可以根据需求声明自己接受那些数据格式

  ```http
  Accept: */*
  ```

  表示接受全部， /前的为网页数据格式，

  ​							/后的为编码格式

- Content-Encoding

  表示压缩的格式

  ```http
  Content-Encoding :gzip
  ```

  常见有 gzip， deflate
  
  请求时客户端也可以声明接受的解压方式
  
  ```http
  Accept-Encoding: gzip, deflate
  ```
  
  



## 2.2GET ,POST

这来就是常见的http头部的 Method 

【**以下均从RFC规范定义**】 出发  

- GET

  - 资源  静态的文本 页面  图片视频等
  - HTTP版本
  - 参数位置  URL 

  从服务器获取指定的资源 

- POST

  - 处理方式   e.g :/submit
  - HTTP版本
  - 参数位置 URL

  根据请求符合（报文的BODY） 对指定的资源做出处理

  比如申请写一段留言   那么就会社区宁在网页的body 部分书写一些东西

- GET POST 方法都安全 和幂等吗

  - 安全

    请求方法不会破坏服务器上的资源

  GET 安全且幂等  因为是【只读】动作        （所以可以对GET进行缓存到浏览器上  也可以存为书签）

  POST  会修改服务器的资源  所以是【不安全】的

  ​             且多次提交就会创建多个资源  所以是【不幂等】的

  不可被缓存



## 2.3 HTTP缓存技术

目的 ： 为了加速网页浏览的速度

- 强制缓存

  只要浏览器判断缓存没有国企  那么就直接使用浏览器的本地缓存   （属于是浏览器的【强制缓存】）

  一般会在Status Code 后的size 项中标明（ **from disk cache** )

  - 有效期

    利用HTTP响应头部（response Header）

    - Cache-Control 相对时间
    - Expires  绝对时间

    

  - 使用Cache-Control 缓存的流程

    - browser 第一次申请访问服务器资源时， 服务器会返回这个资源同时 ，在Response Header 加上 Cache-Control  里面设置【保质期】

    - 再次访问服务器的该资源时  会先通过比较 是否过期  来决定是否使用缓存 或者重新请求服务器

    - 如果服务器再次收到请求， 

      - 如果资源 没更新 那么服务器返回304 Status Code
      - 如果更新了 并成功传回新的页面， 返回200 Code

      会更新Response 头部的Cache-Control

  - 优先级

    如果同时这2个头部  那么Cache Control 的优先级 高于 Expires

- 协商缓存

  响应码时 `304` 代表告诉浏览器 可以使用本地缓存的资源  【服务器告诉客户端是否可以使用缓存】  叫做协商缓存

  即是发现本地的缓存已经过期  向服务器发送更新请求时 服务器发现资源并未更新  就返回304 code  

  可以基于2种头部实现

  第一种

  - 响应头部中的 `Last-Modified` 标识 响应资源的最后修改时间

  - 请求头部中的 `If-Modified-Since`当资源过期了， 发现缓存中有`Last-Modified` 声明，才使用该方法

     客户端发起请求时会发送 带有 Last-Modified  时间  服务器比对看是否需要更新

  第二种：

  - 响应头部的`Etag` 唯一标识响应资源
  - 请求头部中的 `If-None-Match` 过期资源中发现存在 `Etag` 则向服务器发送请求时 将 `If-None-Match`  值设为ETag的字段， 服务器比对，如果变化则更新并返回200

  相对而言后者基于唯一标识实现 会更保险， 避免了由于时间篡改而导致的不可靠问题

  优先级

   Etag  >  Last-Modified 如果Etag没有变化 再看Last-Modified

## 2.4HTTP（1.1）特性

- 优点

  - 简单

    header + body 

  - 灵活和易于扩展

    Method URI/URL Status Code  Header 等每个组成都没有被要求固定死  都允许developer 自定义或补充

    同时HTTP工作在应用层（OSI第七层）则她的【下层可以随意变化】

  - 应用广泛 跨平台

    台式机 到手机上的各种APP 且游戏新闻购物都有应用

- 缺点

  - 无状态双刃剑

    - pro 不会记忆HTTP状态  减少服务器负担 减少CPU跟内存的调动

    - con 服务器没有记忆能力， 完成有关联性的操作会比较麻烦

      - eg ： 登录---> 添加购物车 --> 下单--> 支付   每一个过程都需要知道用户身份才行， 但是服务器并不知道这些有关联，必须每次问一次身份信息

      - solution： `Cookie`

        第一次请求后， 服务器返回一个Cookie （小贴纸）

        第二次以后请求带上Cookie 即可轻松让服务器识别身份

  - 明文传输双刃剑

    - pro 便利性
    - con 不安全

  - 不安全

    - 明文传输  内容可能会被窃听
    - 不验证通信放身份， 可能会遭遇伪装网站  e.g 假淘宝拼多多
    - 无法证明报文完整性  所以有可能已经遭篡改 e.g 网页植入的垃圾广告

    solution ：HTTPs 引入SSL/TLS层 安全上达到了极致



## 2.5HTTP/1.1 性能

①长连接

减少了TCP来凝结的重复建立和断开 导致的 额外开销

只要任意一端没有明确提出断开连接， 则一直保持TCP连接转台

（不过如果HTTP在超过一定时间没有数据交互， 则主动断开这个连接）

② 管道网络传输

因为长连接的存在，可以使（pipeline）传输称为可能

定义： 在同一个TCP连接里，可以发送多个请求，只要有第一个请求发送出去，不必等其回来，第二个就能发出， 减少响应时间

（以前是等待前一个请求回应接受到了才能发出第二个请求）

③队头阻塞

如果前面的请求因为某种原因阻塞， 那么后面也一同被阻塞， （类似赛车）



## 2.6 HTTPS 与HTTPS

### 2.6.1区别

- HTTPS解决HTTP里的不安全缺陷 ， 在TCP和HTTP层增加 SSL/TLS安全协议 使得报文能够加密传输
- 建立过程
  - HTTP连接建立简单， TCP三次握手之后即可进行HTTP传输报文
  - HTTPS在TCP三次握手之后，还要进行SSL/TLS 握手过程 才能进行加密报文传输
- HTTP端口号为80  HTTPS 端口号443
- HTTPS需要向CA（certificate Authority） 社区宁数字证书，to prove the id of server is reliable

### 2.6.2 HTTPS解决了哪些问题

- 窃听 加密报文
- 篡改  通过校验机制，无法篡改通信内容         避免强行植入垃圾广告  但是百度还是可以自己发
- 冒充 有CA的证明

方法：

- 混合加密   保证信息的机密性

  - 非对称加密 ： 

    在通信建立前采用， **交换**【会话密钥】 后续不再i使用非对称加密

    特点： 使用2个密钥（共和私， 公钥可以随意分发，而私钥保密，解决交换问题 但是速度慢）

  - 对称加密

    在通信过程中全过程使用对称加密的【会话密钥】的方式 **加密** 与**解密**明文数据

    <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220809111621718.png" alt="image-20220809111621718" style="zoom:59%;" />

- 摘要算法 + 数字签名 实现完整性 （为数据生成独一无二的【指纹】 校验数据完整性）

  摘要算法：

  通过哈希函数来计算出内容的哈希值， （唯一，且无法通过哈希值推导出内容）

  - ①server 将 content 和哈希值A 一起发送
  - ②client 通过哈希计算重新算出哈希值B 并与A比对， 检验完整性
  - 问题： 无法避免【内容+哈希值】不会被中间人替换
  - 解决 ： 非对称加密算法

  非对称加密：（均可加/解密）

  - 公钥 给所有人
  - 私钥  必须本人管理， 不可泄漏

  第一种： 

  公钥加密， 私钥解密 ： 保证内容传输安全，

  第二种：

  私钥加密， 公钥解密 ： 保证消息不被冒充 

  - trade off
  - 一般不会用非对称加密算法来加密实际的content （比较耗时）， 所以一般只用第二种， 确认消息身份 **数字签名算法**

  算法： 私钥encode 内容的哈希值， 给到client ，用公钥来解密数字签名为哈希值A， 后再比对哈希值AB

  <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220809112252403.png" alt="image-20220809112252403" style="zoom:50%;" />

- 将server公钥放入数字证书中，解决冒充风险

  避免公钥被伪造

  所以出现权威的CA来存储并认证公钥和域名



### 2.6.3HTTPS的TLS握手

- SSL/TLS 协议过程

  - 客户端向服务器索要并验证服务器公钥

  - 双方协商生产【会话密钥】

    （前两部为SSL/TLS 建立过程 【握手】阶段  涉及 【4次】通信， 基于RSA 的握手过程如下：

    （Secure  Socket Layer / Transport layer sucurity)

    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="HTTPS 连接建立过程" style="zoom:45%;" />

    0.  三次握手

     ①ClientHello

    ​			客户端向服务器发起加密通信请求，主要信息包括  

    - 客户端支持的SSL/TLS 协议版本， 如TLS1.2
    - 客户端生成的随机数【Client Random】， 后面用于生成【会话密钥】的条件之一
    - 客户端的密码套件列表 如（RSA加密算法）

    ②ServerHello

    成功接受请求后， 先发送一个ASK 后发出响应个欸客户端 包含如下内容

    - 确认SSL/TSL版本 如果浏览器不支持，则关闭通信
    - 生成随机数【Server Random】
    - 确认密码套件列表，
    - 服务器的数字证书（client 收到证书后利用os里的CA公钥验证证书并取出服务器的公钥）
    - 发送hello done

    ③客户端回应

    回ASK后， 通过浏览器或OS中的CA公钥， 确认服务器的整数的真实性

    如果无问题  那么客户端取出服务器的公钥， 加密报文，向服务器发送

    - 随机数【pre-master key】 （利用公钥加密， 服务器自身利用自己的私钥解密）
    - 做出通知 ： 表示加密同行之后都将会用【会话密钥】进行通信（此时第一次刚好拥有3原件 可以组成会话密钥）
    - 客户端握手结束通知  并将之前发声的所有数据做个摘要， 提供服务端**校验**

    ④服务器的最后回应

    通过【pre-master key】，经过协商的加密算法 计算出本次的【会话密钥】

    然后发出

    - 做出通知： 接下来的信息会用【会话密钥】进行加密
    - 将之前发声的所有数据做个摘要， 供**校对**

    

  - 接下来都采用会话密钥通信

### 2.6.4HTTPS应用数据如何保证完整性

TLS分为

- 握手协议

  TLS四次握手过程 协商加密算法和堆成密钥

- 记录协议

  保护应用程序数据完整性和来源 （在利用密钥加密时，使用此协议）

记录协议负责 ① 消息（HTTP数据） 压缩，加密 认证

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png" alt="img" style="zoom:30%;" />

- 消息被分割成多个片段  并进行压缩
- 在压缩片段后加上【消息认证码】MAC值（通过哈希算法生成） ----for 保证完整性的数据验证
- 一起合并后，通过【会话密钥】进行加密
- 最后加上报头  包含数据类型， 版本号， 压缩密文的长度

### 2.6.5可优化部分



## 2.7 HTTP/1.1 2.0 3.0 的变化

### 2.7.1HTTP/1.1

相较。1.0 改进

- 利用pipeline网络传输， 减少整体响应时间
- 利用长连接， 减少不必要的通信开销

存在的瓶颈：

- Header 未经压缩就发送  且每次都发送相同的也没有优化
- 队头阻塞：  按照请求顺序响应， 前面有未完成的，那么后面都无法开始、
- 请求只能从客户端开始， 服务器只能被动响应

如何优化：

- ①避免发送HTTP请求
- ②必须发送时， 减少发送次数
- ③减少Server 的HTTP响应的数据大小

①通过缓存避免发送HTTP请求

②减少发送次数

- 减少重定向请求次数

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img" style="zoom:33%;" />

  将重定向的工作分给代理服务器来做

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img" style="zoom:33%;" />

  如果代理服务器已经知道了重定向的地址（规则） 那么就又可以省略代理服务器 ---> 源服务器（url1 与源服务器302的response） 的一步来回， 直接发送/url2  源服务器返回200 资源2；

- 合并请求

  把多个小的请求合并为一个大的HTTP资源请求

  好处： 

  - ①减少了HTTP头部的重复发送

  （且以你为HTTP/1.1为请求响应模型， 会产生【队头阻塞】 每个请求都会造成一次TCP连接）

  - ②如果合并了请求，那么也就减少了TCP连接的数量，因此省去了TCP握手和慢启动过程耗费的时间

  例子

  - 网页的很多小图标， 小图片 合并成一个大图片（利用 【CSS Image Sprites】）， 再根据CSS数据把大图片分割成小图片
  - Server 端，用【webpack】等打包工具，将js，css等资源合并打包成大文件

- 延迟发送请求

  【按需获取】，当用户滑到相应位置，再向服务器获取接下来的资源

③通过【压缩】 减少响应数据大小

- 无损压缩

  gzip ：

- 有损压缩

  可以通过Header中的Accept 字段里的【q质量因子】来告诉服务器期望的资源质量

  



### 2.7.2 HTTP/2

基于的时HTTPS  所以HTTP/2也有安全保障

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png" alt="HTT/1 ~ HTTP/2" style="zoom:50%;" />

- 头部压缩

  如果发送多个请求 且 头部一样或相似， 那么会消除重复的部分

  （即 **HPACK**算法 ： Client 和Server 共同维护一张 Header信息表， 所有字段都存入这个表，生成索引号， 这样就减少了发送的耗损）

  - 静态表编码

    1-61个最常用的字符串

    - ​	用index 标记， 省去长字符串所耗费的字节成本
    - ​    用Huffman压缩发压缩

    第一个字节为01 + index（6个bit） 第一部分代表是否为定值  第二个部分为index

    第二个字节为0/1 (是否为Huffman加密）+value length 

  - 动态表编码

    从62开始

- 二进制格式

  Header 和body 全面使用二进制， 统称为帧（frame）

  方便机器传输和解析， 无需进行中间报文的encoding 和decoding  增加效率

- 数据流

  因为数据包不是按照顺序发送的  所以必须对数据包进行暴击

  ​                   定义： 每个请求或回应的所有数据包 被称为一个数据流（stream） 每个数据流都有一个【steam ID】 

  因此可以实现【并发发送】

  ​                   区别：客户端建立的必须是奇数号， 服务器偶数好

  ​                   优势 ： 客户端还能指定数据流的优先级， 优先级高的，服务器先响应

- 多路复用

  可以并发多个请求和回应， 解决【队头阻塞】 降低延迟  提高连接利用率

- 服务器推送

  解决服务器被动地位， 可以主动向客户端发送信息

  <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220810075005335.png" alt="image-20220810075005335" style="zoom:50%;" />

  比如可以主动发出CSS文件， 减少消息传递次数

缺陷 ：

- 还是存在【队头阻塞】问题，只不过实在TCP这一层

  多个请求复用一个TCP连接解决了HTTP队头阻塞问题， 但是一旦丢包，就会阻塞所有HTTP请求，即客户端无法收到丢包后的所有包

### 2.7.3 HTTP/3

<img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220810075248267.png" alt="image-20220810075248267" style="zoom:50%;" />

因为HTTP/2 的TCP层队头阻塞问题， HTTP/3 使用了UDP（不可靠传输） 但是基于【QUIC】协议， 一样可以所hi先类似TCP的可靠性传输

QUIC 的特性：

- 无队头阻塞

  多路复用 同一个Link 并发多个Stream

  而且保证可靠性： 当某个stream发声丢包时， 只会阻塞这个流， 其他流不受影响， 不触发队头阻塞问题

- 更快的连接能力

  QUIC三次握手即可开始传输 不需要TLS握手（同时保证安全性）

- 连接迁移

  在TCP中 通过四元组（源IP，源port 目的IP， 目的port） 确定一条TCP连接， 那么移动设备从流量变成WIFI时 IP发声了变化， 那么必须重新建立连接

  此时就必须重新【3此握手加TLS四次握手】的时延，一起TCP的慢启动减速过程

  解决：

  QUIC协议中 没有四元组， 通过 【连接ID】 来标记通信2个端点，因此即使IP变了， 只要保留有上下文（context） 信息（连接ID， TLS密钥）等，就可以无缝复用原链接， 消除重连成本。  



 

# TCP

## 1.基本认识

### 1.1 TCP 头部

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn?x-oss-process=image/format,png" alt="TCP 头格式" style="zoom:50%;" />

【序列号】在建立连接时由计算机生成的随机数为初始值。 通过SYN包传给接收端主机，每发送一次就【累加】一次该【数据字节数】大小。 解决网络包乱序问题

在到达4bytes 最大之后， 直接循环到0

【确认应答号】 下一次【期望】收到的数据的序列号，发送端收到这个确认应答后， 可以认为这个序列号之前按的数据都已经被正常接受。解决丢包问题

【控制位】

- *ACK*：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
- *RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
- *SYN*：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。

### 1.2TCP工作

**产生原因**：

解决IP传输的不可靠性。

**工作区层**：传输层

**特性**：

能保证传输的可靠数据传输服务，能保证接受的网络包时【无损坏】【非冗余】【无间隔】【按序】

TCP传输时具有

- 每个消息分组

- 每个消息的报文边界  保证完整性
- 对于重复的包选择丢弃 【无冗余】
- 按照顺序读取，即使属于后面的包被接收到了，但队头的包未被读取到，也无法读取后面的。

**属性**：

TCP是【面向连接】的，【可靠的】，基于【字节流】的传输层通信协议。

- 面向连接： 一定是【一对一】连接，且基于双方认可

  （UDP一对多）

- 可靠性。 ：无论链路层发声什么链路变化， TCP都能保证一个报文达到接收端

- 字节流。 

**定义**

【连接】

用于保证可靠性和流量控制 维护的某些状态信息（Socketssquence, numbers, window sizes)

实际上在TCP中，我们需要

- 源地址IP（IP头部） 32位  通过IP协议发送给主机
- 目标地址IP
- 源端口地址（TCP头部）16位 通过TCP协议发送给哪个进程
- 目标端口地址

四元组，作为唯一确认的连接

TCP最大连接数也和此2个有关 = 客户端IP数 * 客户端端口数

（e.g IPV4 ： IP最多 2的32次方  端口数最多2的16次方  乘一起 2 的48次方）

而实际难以达到理论上线，会受到如下因素印象：

- 文件描述符限制 ：每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：
- 内存限制

## 2.与UDP区别

- UDP

  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEyLmpwZw?x-oss-process=image/format,png" alt="UDP 头部格式" style="zoom:50%;" />

  利用IP提供面向【无连接】的通信服务

  - 端口号 决定发送给哪个进程
  - 包长度 保存了UDP首部的长度和数据的长度之和
  - 校验和 防止收到受损或收更改的UDP包

区别

- 连接

  TCP面向连接

  UDP不需要连接， 即可传输数据

- 服务对象

  TCP 一对一

  UDP一对多，多对多都可以

- 可靠性

  TCP > UDP

- 拥塞控制，流量控制：

  TCP有拥塞控制和流量控制，保证数据传输的安全性

  UDP则没有， 即使网络非常拥堵也**不会影响**UDP传输速度

- 首部开销

  TCP(没有使用【选项】时为20Bytes) > UDP(8 bytes 固定不变)

- 传输方式

  TCP是数据流传输， 没有边界， 但有确保边界的信息 和确保顺序可靠

  UDP是一个包一个包的发送，有边界，但可能丢包或乱序

- 分片

  TCP会根据MSS（maximum segment size） 在传输层进行分片。如果丢了一个片，那么只需要重新传输这个分片即可

  UDP数据包如果大于MTU（maximum transition unit）大小则在IP层分片

- 应用场景：

  TCP 保证可靠向， 以及面向连接

  - FTP文件传输
  - HTTP/HTTPS

  UDP 随时传送数据， 且简单高效

  - 包总量较小的通信： DNS，SNMP
  - 视频， 音频
  - 广播

### 2.1为何TCP没有包长度

TCP数据长度 = IP总长度 - IP首部长度- TCP首部长度（前2在IP头部可查， 后者在TCP头部可查）

UDP其实也可以这么算，但是可能为了不全首部长度为【4bytes】整数倍， 不全了包长度

## 3.TCP连接简历

### 3.1三次握手过程

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom:50%;" />

从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。

第三次握手的seq num = client_isn + 1;

### 3.2为什么一定是三次（功能）

- 避免历史连接

  连续多次发送了2个包，一次seqnum = 90， （因为超时，所以重新建立连接SYN）另一次 = 100. 

  那么此时他所【期待】收到的ACK num应该是100+ 1 所以即使server端先收到了90的包，返回91的acknum 给client 端，client端此时返回RST，（中断连接），（因为他期待的是100+ 1）而是等到100 + 1才响应

  【如果是2次就无法阻止历史连接】：server端在收到90并发送90+1的ACK SYN包后直接处于Established状态，此时可以发送数据了，但是实际上client端根本收不到，（浪费资源） 而紧接着会收到RSTfrom client 才会断开连接

- 同步双方初始**序列号**

  一个发送SYN报文，一个返回ACK（Seq num + 1）报文 才能确认序列号可靠

  实际上四次也可以，就是server端先发一个ACK， 再发SYN 但实际上没必要，可以收缩成3次

- 避免资源**浪费**

  同①

综上，  2次会造成资源浪费，且历史连接不能避免，无法同步双方的序列号（只能确保以一方的序列号被成功接受）

​			 4次可靠，但是也没必要，造成资源一定的浪费



### 3.3为何每次建立连接都需要随机的初始序列号

因为如果不这样， 那么在2者建立连接之后，此时有一个包未被正常接受，可能在堵塞中，server端就停电了，重启后重新建立连接，那么此时哪个包刚好到达，那么server端也是会接收到的，这就导致了问题。





### 3.4既然IP会分片，为何TCP还要MSS



<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzIzLmpwZw?x-oss-process=image/format,png" alt="MTU 与 MSS" style="zoom:50%;" />

那么如果存在一个超过 MTU的包需要发送，Ip层就要进行分片，但是如果一个IP分片丢失，整个IP报文都要重传。

【因为IP层没有超时重传机制】 他由TCP层负责超市和重传。

当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。

因此，可以得知由 IP 层进行分片传输，是非常没有效率的

【MSS】值可以经过双方协商决定

而TCP分片丢失后，也是按照MSS为最大单位进行重发，而不用整个包重发



### 3.5第一次握手丢失后，发生什么

发送完SYN包后，client端会处于 【Syn Sent】状态

在限定时间内没有收到ACK +SYN包，即会重传SYN包

但是注意有区别

+ 每次超时重传的限定时间是上次的2倍（比如第一次超时是1s后，第二次2s）
+ 最多重传次数由 tcp_syn_retries 规定， 一般为5
+ 第五次超时重传后，会等待32秒，如果还没有收到回复，就直接断开TCP连接

所以，最终总耗时为63秒 大约分钟





### 3.6第二次握手丢失

在server端发送SYN-ACK报文给客户端后 Server 端进入SYN_RCVD状态

- client 端因为收不到第二次握手的报文，那么会认为是自己的第一次握手丢失了，会机型重传SYN报文
- server端也因为没有收到第三次握手的报文，于是会除法超时重传机制，重传SYN-ACK报文
- 重传次数 由 tcp_synack_retries 规定默认为5



### 3.7第三次握手丢失了会发声什么

客户端发送ACK报文后，机会变成ESTABLISHED状态

此时server端久久没收到第三次握手，那么就会重传SYN + ACK 报文，直到收到第三次握手或者达到最大重传次数

**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

## 4.TCP断开连接

### 4.1四次挥手过程

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzMwLmpwZw?x-oss-process=image/format,png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:50%;" />

- 客户端打算关闭连接，调用完close函数后，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSED_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务器收到了 `ACK` 应答报文后，就进入了 `CLOSED` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSED` 状态，至此客户端也完成连接的关闭。



四次挥手的原因

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务器收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，从而比三次握手导致多了一次。

### 4.2第一次挥手丢失

重传FIN报文，重发次数由 tcp_orphan_retries 参数控制

如果超过次数后，就直接进入clos状态



### 4.3第二次挥手丢失

因为ACK报文不会重传，所以此时client 端会认为是自己第一次挥手丢失从而 client端重发FIN报文  



### 4.4第三次挥手丢失

如果丢失了，那么server端救会重发FIN报文  （依然由 `tcp_orphan_retrie`变量控制， 与client端一值）

- 此时的客户端

  处于FIN_WAIT2状态，不能发送信息，但是能接受信息，但是close函数已经使用，进程被关闭，FINWAIT2状态也不能持续太久，所以有   tcp_fin_timeout 变量控制这个状态的连接时长，默认为60s

  这意味着对于close 已经关闭的连接， 在60s内还没有收到FIN报文，客户端就会直接关闭



### 4.5第四次挥手丢失

如果第四次挥手的ACK没有到达服务端，呢么服务端就会重发FIN报文，重发次数依然由tcp_orphan_retrie控制

### 4.7为什么需要 TIME_WAIT状态

- 保证【被动关闭连接】的一方，能正确的被关闭

  如果此时client发送完ACK之后便直接变成CLOSED状态，那么如果ACK包丢失，则server端重发FIN包，client 端便会返回RST包，使得server端异常关闭

  

  如果对方没有收到ACK，便会除法TCp重传机制，服务端重发FIN，这样一来一去刚好2个MSL的时间

- 防止历史连接中的数据， 被相同的四元组的的连接错误接受

  （有可能存在 close函数调用前，服务端发送给客户端的包因网络延迟而没发送成=功，server 重传。而此时客户端已经close。就会以相同等分四元组打开连接， 并重传该包，就会导致数据错乱） 

  为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 `2MSL` 时长，这个时间**足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。**

### 4.8如果已经建立了连接，但是客户端突然出现故障了怎么办

- **保活机制**

  会存在一个时间间隔，发送一个探测报文，如果连续几次探测报文都没有响应，则认为当前的TCP已经死亡。

  有如下参数保证：

  - ```shell
    net.ipv4.tcp_keepalive_time=7200 #保活时间2小时， 2小时内如果没有任何活动就启用保活机制
    net.ipv4.tcp_keepalive_intvl=75  #见此时间75s
    net.ipv4.tcp_keepalive_probes=9	 #如果9次无响应认为对方已经不可达，中断该连接
    ```

  所以以上例子中，至少7875s才能发现生效

  开启了TCP保活，有以下几种情况：

  - 当探测报文中场响应时，TCP保活机制会被 【重置】 等待下一个TCP保活时间的到来
  - 对端程序崩溃并重启，当TCP报文发送给对方后，还是可以响应的，但是只有一个【RST】报文，那么TCP连接就已经重置
  - 对端程序崩溃，那么连续几次都没有响应，则TCP报告该连接已经死亡

### 4.9server端发生崩溃了如何

在server端kill掉进程后， server端会自己发送FIN报文，与客户端进行四次挥手

## 5.TCP几大特性

### 5.1 重传机制

①超时重传

- 数据包丢失
- 确认应答丢失

上述2情况为超时重传触发的情况

- 超时时间应该设置为多少
  RTO（Retransmission Timeout）
  RTO较小容易造成重发的包会很多，造成网络拥堵； 较大时没有效率，性能差
  最合适的情况是 ： **RTO的值略大于RTT（round-trip time） 往返时延**
  因为RTT是随着网络不断变化， 所以RTO也是一个动态变化的值
  
  - linux 计算RTO方法
    - 采样RTT的时间，进行加权平均
    - 采样RTT波动范围
  
  

②快速重传

以数据驱动而非时间

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制" style="zoom:50%;" />

- 第一份 Seq1 先送到了，于是就 Ack 回 2；
- 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
- 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
- **发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。**
- 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 

所以其工作方式是 连续收到3个相同seq的ACK报文，在定时器过期之前，重传丢失的报文段

- 但是重传一个的话就会导致Seq3报文（已丢失）还得等后续重复发3次ACK3才能重传。
- 重传全部就会导致浪费资源（因为Seq3以后的都已经接受完毕）



③SACK方法（selective Acknowledgement）选择性确认

在TCP头部添加一个`SACK` 可以将已收到的数据信息发送给【发送方】 这样就可以通过对比，找到没被收到的数据，进而精准重传

如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。

ACK为在此code之前的报文全部已经收到

SACK为在这个范围内的报文已经收到，通常开始的code需要在ACK之后

![选择性确认](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

④D-SACK（duplicate SACK）

告诉【发送方】有哪些数据被重复接受

以上的三种方法都基于ACK重发的机制上

而D-SACK可以解决

\- ACK丢包问题

 在【接收方】重复收到数据包【3000 - 3499】时，会返回一个SACK = 3000-3500 ACK = 最新ACK 的报文给发送方，这样就可以确认时ACK报文丢失

\- 网络延迟

 当中间【1000 -1499】因为网络延迟无法到达【接收方】，且【发送方】三次接收到ACK = 1000的报文，触发【快速重传】机制，重发了【1000-1499】数据包，（而在这之间刚好之前的1000-1499的报文到了。）

 于是此时在第二次收到【1000-1499】报文时，D-SACK触发，返回最新 ACK 且SACK = 1000-1500

### 5.2滑动窗口

在窗口大小范围内，无需等待确认应答，即可继续（允许范围内的）发送数据。

如图所示，若窗口大小为3个TCP段，那么发送方可以来纳许发送3个TCP段，且中途有ACK丢失，也可以通过下一个确认应答确认

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="用滑动窗口方式并行处理" style="zoom:50%;" />

- 窗口大小的确认
  在TCP头部中有Window 的字段，是【接收端】用来告诉【发送端】自己还有多少缓冲区来接受数据。
  
- 发送方的滑动窗口
  
  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg?)
  
  - \#1 是已发送并收到 ACK确认的数据：1~31 字节
  - \#2 是已发送但未收到 ACK确认的数据：32~45 字节
  - \#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节
  - \#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后
  
  在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了
  
  ![可用窗口耗尽](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/17.jpg?)
  
  在下图，当收到之前发送的数据 `32~36` 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则**滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认**，接下来 `52~56` 字节又变成了可用窗口，那么后续也就可以发送 `52~56` 这 5 个字节的数据了。
  
  ![32 ~ 36 字节已确认](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/18.jpg)
  
  

通过四个指针实现滑动窗口的功能

![SND.WND、SND.UN、SND.NXT](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

- 

  - `SND.WND`：表示发送窗口的大小（大小是由接收方指定的）；
  - `SND.UNA`（*Send Unacknoleged*）：是一个**绝对指针**，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。
  - `SND.NXT`：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。（与UNA可以重合，当可用为满时）
  - 指向 #4 的第一个字节是个**相对指针**，它需要 `SND.UNA` 指针加上 `SND.WND` 大小的偏移量，就可以指向 #4 的第一个字节了

- 接收方的滑动窗口

  - \#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；
  - \#3 是未收到数据但可以接收的数据；
  - \#4 未收到数据并不可以接收的数据；

  ![接收窗口](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg)

  一共三个指针，如图所示2个绝对的指针，加上一个相对指针指向#4的第一个字节，需要RCV.NXT + RCV.WND的大小的偏移量即可

### 5.3流量控制

目的：避免因数据传输过快而引发过多的重发机制，造成流量浪费

**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

实际上是 当发送方接收到ACK信号后才能将window 向右移动数据包大小的距离

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/21.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="流量控制" style="zoom: 33%;" />

**窗口关闭**
如果窗口大小为0时，就会组织发送方给接收方船体数据， 知道窗口变为0为止。
通知方式： 【接收方】通过ACK报文来通告【发送方】
- 潜在的风险：
  在接收方接收完毕当前所必须的数据后，会发送一个ACK报文，附带Window-size = 0
  此时发送方接收到之后窗口直接关闭，不在传输数据，
  如果此时【接收方】处理完数据后，仍然想要重新打开窗口，那么就会发送一个Window > 0的ACK报文给【发送方】，
  此时如果此报文丢失，那么双方都会陷入等待的死锁现象。
- 如何解决：
  TCP每个连接都有一个**持续定时器**，只要一方接受到对方的【零窗口】通知，就启动该持续计时器
  如果持续计时器超时，就会发送【窗口探测】报文，向对方确认窗口的大小，
  - 如果此时窗口仍为0，那么持续计时器就会重启
  - 如果不是0， 那么死锁就可以打破

**糊涂窗口综合征**
😎 小牛肉：糊涂窗口综合症就是接收方窗口变小，导致发送方每次发送的数据只有一个大大的头部，真正携带的数据很少。

可以从接收方和发送方分别进行处理：

发送方：

- 方案 1：只要窗口大小 = 内核缓冲区大小的一半 的时候，才打开窗口，通告发送方，告知其可以发送数据。这样就可以防止发送方发送小报文了
- 方案 2（延迟确认应答）：延迟确认应答其实是针对如果接受数据的主机在接收到报文的时候就立刻返回 ACK 应答的话，这时候返回的窗口可能比较小。如果接收方稍微等一会再应答，那么这个时候接收的数据已经被处理完了，从缓冲区中被清理出去了，这样的话，窗口就变大了，发送方能够发送的数据也就更多了

接收方：
- Nagle 算法：指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，当满足已发送的数据都已经收到确认应答时；或者可以发送的数据大小 >= 内核缓冲区大小的一半时，才可以发送数据。这样，从发送方的角度去防止了小报文的发送

### 5.4拥塞控制

流量控制负责避免【发送方】数据填满【接收方】缓存，但是并不知道网络出现了什么

拥塞控制就是避免【传送方】的**数据填满整个网络**

（发生拥堵时，一旦无节制的发送数据包，就会导致报文的丢失或者超时，进而触发重传机制，导致网络负担更重，形成恶性循环）

- 拥塞窗口

  cwnd （发送方维护的一个状态变量，根据网络的拥塞程度而动态变化）

  所以此时的swnd（sender window） = min（cwnd， rwnd）

  - 变化规则

    cwnd 随着拥塞出现而降低窗口大小

  - 作用机制

    发生了超时重传，就会认为网络出现了拥塞

相关的控制算法

- 慢启动

  一点一点提高数据的发送量，

  （每收到一个ACK， cwnd 就增加一个数据包的发送量）（翻一番）

  为了避免指数型增长，引进ssthresh（slow start threshold）

  - cwnd < ssthresh 启用慢启动算法
  - cwnd >= ssthresh 启用【拥塞避免算法】

- 拥塞避免算法

  **每当收到一个 ACK 时，cwnd 增加 1/cwnd（即只增加1个单位）。**

  还是会增长，直到发生拥塞，出现丢包，触发重传机制，进入【拥塞发生算法】

- 拥塞发生

  拥塞时会发生数据包重传

  - 超时重传

    ①ssthresh 设为 cwnd/2

    ②cwnd重置为1

    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞发送 —— 超时重传" style="zoom:33%;" />

  - 快速重传

    因为三次收到前一个包的ACK，不一定时因为拥塞发生的，所以TCP对应处理也轻缓许多

    ①cwnd = cwnd / 2

    ②ssthresh = cwnd（直接开始拥塞避免算法）

    ③进入快速恢复算法

- 快速恢复

  那么紧接着快速重传，发生以下操作：

  - 拥塞窗口 cwnd = ssthresth + 3 （3 means 3 个数据包被收到）
  - 重传丢失的数据包
  - 如果再收到ACK将cwnd增加1
  - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传和快速恢复" style="zoom:33%;" />

### 5.5TCP如何保证传输的可靠性

【不被修改】【按序】【不冗余】【无缺失】【不爆栈】

1. 数据包校验
2. 对失序数据包重新排序（TCP报文具有序列号）
3. 丢弃重复数据
4. 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
5. 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
6. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出

## 6 TCP协议一定不会丢数据吗

### 6.1 建立连接时丢包

- 发送数据的过程

  - 三次握手建立TCP连接

    //前期

  - 将数据拷贝到OS种的send buffer

  - 经过传输层 加上TCP头部 经过网络层 加上IP头部

  - 经过qdisc （流控）到达数据链路层 加上MAC头部

  - 到达ringbuffer 发到物理层的网卡里，

    //sender

  - 数据经过n个路由器何交换机，到达目的机器的网卡处

    //网络

  - 网卡通知【DMA】将数据包放到RingBuffer种 触发一个硬中断给cpu， cpu触发一个软中断让ksoftirqd去Ringbuffer收包，

  - 顺着原先的层级到达聊天软件里

  <img src="https://img-blog.csdnimg.cn/img_convert/28e4d6b004530fbf75fe346d181baa81.png" alt="网络发包收包全景图" style="zoom:50%;" />

- 半连接队列

  第一次握手后， 建立**半连接**， 然后发出第二次握手， 有些地方需要暂时存储这些半连接， 称为【半连接队列】

- 全连接队列

  第三次握手到达服务端以后，半连接 就会升级位全连接， 等待服务端的程序执行 【accept()】将其收走

- 存在的风险：

  如果队列已经满了， 那么新来的包就会被丢弃，从现象上看就是连接失败， 所以如果服务器被过多的SYN连接攻击， 那会造成网站的暂时性失效（即  ： 无法与外界有意义的连接产生有效的半连接）

### 6.2流量控制丢包

- qdisc（Queueing Discipline， 排队规则）

  基本作用机制 ： 队列

  存在风险 ： 队列满的时候（txqueuelen不够大） 容易出现丢包的情况

  查看方式 ifconfig 命令， 看TX下的dropped字段， 大于0 时出现了流控丢包

  解决方式， 修改流控队列长度

  命令： ifconfig eh0  txqueuelen 1500



### 6.3 网卡丢包

原因众多 比如网线质量差， 接触不良， 而系统性的因素有以下：

- RingBuffer 过小

  在内核中如果缓冲区的处理速度 远远小于 网络传输的速度， 或者缓冲区国小，就会导致溢出， 无法正常接收网络传输过来的数据

  用ethtool命令 可以查看

  - 查看第0号的RingBuffer的丢包数

  - ```shell
    # ethtool -S eth0|grep rx_queue_0_drops
    ```

  - 查看网卡的配置

    ```shell
    #ethtool -g eth0
    Ring parameters for eth0:
    Pre-set maximums:
    RX:        4096
    RX Mini:    0
    RX Jumbo:    0
    TX:        4096
    Current hardware settings:
    RX:        1024
    RX Mini:    0
    RX Jumbo:    0
    TX:        1024
    ```

    含义是RingBuffer 的最大长度位4096， 但实际上只用了1024

  - 可以通过命令改变BufferRing的接受长度

    ethtool -G eth1 rx 4096 tx 4096

- 网卡性能不足

  网卡的性能单位一般是 Mb/s （b means bit = 1/ 8 Bytes）

  所以1000兆的网速 意味着 125MB/s

  txKb/s ☞ 每秒【发送】的字节总数

  rxkB/s ☞ 每秒【接收】的字节总数

### 6.4接收缓冲区丢包 （Recieve Buffer）

在socket 和TCP 传输层之间

OS在buffer拥塞时解决方法

- 发送缓冲区

  - 阻塞调用

    直接干等，等到缓冲区有空位了再直接拍进去

  - 非阻塞调用

    直接反黑EAGAIN 的错误

    让应用重新尝试，这样

- 接受缓冲区

  此时TCp接受窗口会编程零窗口

  那么此时发送过来的数据都会直接**丢包**

### 6.5网络之间丢包

查看丢包率

- ping命令

  ping + 服务器名字

- mtr 命令

  mtr -r 加服务器url 可以看到每一跳的机器对应得丢包率

### 解决方法：

用TCP传输 ： 会利用ack报文来确认已经丢了数据  如果迟迟没有收到， 那么就会发生重传

那么用了就一定不会丢包吗：

不是的，因为TCP保证的可靠性， 时传输层的可靠性， 也就是说只保证数据从 【A的传输层】可靠的传递到【B的传输层】那么 在应用层是否能收到， TCP并不管

- 发送过程：

  （不管发生丢包重传与否，）最后B段收到了数据包后，都会回应一个ack包， A端收到之后，就会将【发送缓冲区】里的消息给扔掉， 那么TCP的仍无就结束了

- 风险：

  应用层中，应用在读取TCP receive buffer 时手机内存不足导致软件闪退， 所以消息可能会丢



### 真正解决方法

TCP + 确认应用层的可靠性

- 服务器

  在用户之间不再是 直接连接，而是中间增加一个中继的服务器，记录发送过的信息，并每次重启时对比当前应用中的最新数据是否与服务器中一致

  （对账其实双端连接也可以做到，但是：）

  除了可靠性以外，还有以下特点：

  - efficiency： 如果有1000个好友那就得建立1000个连接，但是有服务器，只用建立1个连接即可， 消耗的资源小， 手机省电

  - 安全问题 ： 2端通信时如果对方强行跟你连接， 那么就会导致跟对方也发生对账，并且造成信息泄露

    引入第三方服务端后就可以做鉴权的处理和校验

  - 软件版本问题 ： 如果双方的软件版本不同，那么信息可能就不饿能正常兼容， 但是服务器可以把一些信息给增加兼容逻辑， 比如直接去除， 或者转化位精华信息

## 7.TCP的缺陷

- 难以更新

  老版本的TCP连接已经被广泛应用，且很多window 版本不支持新的特性，较难推广

- 建立连接的延迟

  三次握手后还得 + HTTPS的 TLS/SSL握手

  - 解决方法： TCP fast Open

    第一次时还是一样的三次握手，但是增加了一个 **在第二次握手时，发送一个Cookie ** 且第三次握手可以直接发送HTTP请求

    可以在后面的第二次请求时， 接收端的握手  直接 发送SYN + Cookie + HTTP GET 即可获得SYN + ACK + Data

    （即 在握手完成之前完成数据的传输）

    客户端实际上也得返回ACk 以完成握手过程，但实际上已经不重要， 因为已经可以开始传输数据了

    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-Wireshark/45.jpg" alt="常规 HTTP 请求 与 Fast  Open HTTP 请求" style="zoom:50%;" />

  - TLS 和TCP 的握手难以结合

    因为TLS是在应用层实现的握手， TCP是在内核实现的握手， 无法结合起来 

    TLS无法对TCP头部加密， 意味着TCP的序列号都是明文传输， 存在安全问题

    - 所以必须采用三次握手确认双方的序列号  并且是随机产生的

      但是只能避免预测序列号， 如果中途截获了RST报文。伪造合法的报文，也可以进行攻击

    解决方法： 可以将TCP序列号加密， 就可能不需要三次握手了， 直接都可以从0 开始序列号， 也不用做同步序列号的工作， 但是需要更改整个协议栈

- TCP存在队头阻塞问题

  TCP层必须保证字节数据完整且有序， 没法解决这个问题

  如果中间缺失一块， 那么后面的都会被堵截在内核， 无法被应用层读取到

  解决方法： UDP + 安全保障协议

- TCP 更换IP时要重新建立TCP连接 （慢启动）



## 8.如何优化TCP

### 8.1三次握手的优化

- 客户端

  可以在网络较为繁忙时， 降低 tcp_syn_retries 的大小， 从而不让syn_sent状态持续过久， 使得等待时间过长，问题包路时间过长

- 服务端优化

  ①接受SYN的处理优化

  增大半连接队列的大小，

  或者开启syncookie ，直接不使用半连接队列， 

  接收到SYN 立即返回SYN cookie 包含在第二次握手的SYN + ACK报文中， 然后后续客户端发来ACK报文，取出该值验证是否合法， 即可建立成功

  ② SYN_RCVD状态优化

  减少 tcp_synack_retries的次数 ， 尽快暴露问题

  ③accept 队列已满

  如果收到的连接过多，但是又没有成功调用accept函数， 那么就会导致accpet（全连接）队列爆栈，

  此时 直接丢掉ack报文即可， 因为后续客户端已经处于established状态， 会重复发请求（带有ACK报文） 可以根据ACK报文在放入全连接队列建立连接

  或者可以增长accept 队列的长度

  

- 直接使用fast open 



### 8.2四次挥手

分为【主动方】【被动方】

- 主动方优化

  ①减少FIN问重发的次数

  ②如果是close函数关闭的连接， 

  - 那么减少FIN_WAIT2的状态的时间 （防止等待时间过长，提前关闭连接）
  - 减少孤儿连接上限次数，

  ③调整time_wait的上线个数 （超时直接释放）

  （还可以复用time _wati状态的连接， 不过只适用于客户端）

- 被动方连接

  减少重发 Fin报文的次数

### 8.3数据传输优化

①扩大窗口的size ：

接受方主动发送（只有接收方能决定窗口大小）

②传输速度与缓冲区的关系：

比如最大带宽是100MB/s RTT是10ms， 那么在【客户端】到【服务端】网络一共最多存放  1 MB的字节， 称为【**带宽时延积**】 如果飞行报文超过这个值的大小， 就会造成丢包

发送缓冲区 决定了 发送窗口的上限， 而发送窗口又决定了 【以发送未确认】的飞行保温上限， 所以发送缓冲区不饿能超过 【BDP】

调整发送缓冲区的动态变化范围可以优化大小  根据你的BDP

③调节接收缓冲区的范围

④可以主动打开动态变化的设置， 依据是TCP内存范围

⑤调节TCP内存范围

## 9.如何基于UDP实现可靠传输

HTTP/3 即应用此方法，解决了TCP的4大问题

即使应用了 **QUIC**协议

<img src="https://static001.geekbang.org/resource/image/ab/7c/ab3283383013b707d1420b6b4cb8517c.png" alt="img" style="zoom:33%;" />

### 9.1QUIC Header

- QUIC packet Header

  - long Packet Header 用于建立连接
  - Short PAcket HEader 用于日常传输数据 

  <img src="https://img-blog.csdnimg.cn/bcf3ccb6a15c4cdebe1cd0527fdd9a5e.png" alt="Packet Header" style="zoom:33%;" />

  利用三次握手建立连接 ， 目的　：　协商连接的ＩＤ(源连接ID 和目标连接ID)

  后续传输中只需要固定住连接ＩＤ就可以实现连接迁移功能

   

  packet NUmber 是独一无二的编号, 严格递增, 如果就算Packet N 丢失了, 重传的Packet N也不等于N了 而为 N+ M

  - 好处 : 

    ①可以判断到底是[重传报文]还是[原始报文]传给的 服务端

    可以精确计算 RTO（round trip time） 从而可以计算 RTO （retransmission time out）

    ② 支持乱序确认， 因为丢包重传当前窗口阻塞在原地， 而TCP必须顺序确认， 丢包时，导致窗口不华东

  

- QUIC Frame Header

  <img src="https://img-blog.csdnimg.cn/536298d2c54a43b699026bffe0f85010.png" alt="img" style="zoom:33%;" />

  - Stream ID 并发HTTP消息，通过StreamID 加以区别，类似HTTP/2中的
  - offset 作用： 类似TCPSeq序号， **保证数据的顺序型和可靠性**

  丢包以后 ，重发的 Stream ID 和Offset 字段都一致，

### 9.2 解决队头阻塞问题

给每一个Steam都分配一个独立的滑动窗口， 使得一个连接上的多个Stream 没有以来关系，彼此独立。

- 局限性

  但是同一个Stream 里面如果发生了丢包 ，也会造成窗口无法滑动，

  这无法优化， 要不然无法保证Stream的有序可靠性

### 9.3流量控制

方式：

- 通过window_update 帧告诉【发送方】窗口大小
- 通过BlockFrame 告诉对端， 已经被阻塞（由于流量控制）

有2哥方面的流量控制

- Stream 的流量控制
- Connection 的流量控制 （ Sum of streams window size）

### 9.4改进拥塞控制

QUIC 默认使用了TCP的Cubic拥塞控制算法（慢启动 拥塞避免 快重传 快恢复策略）

改进：

- 迭代速度很快

  QUIC属于在应用层的协议，可以随浏览器更新而更新， 可以及时更新哦那个色控制算法

- 针对不同的应用设置不同的拥塞算法，  灵活性高

### 9.5 更快的建立连接

包含了TLS的集成

3次握手即可， 确认连接的ID

重新连接时可以直接一次握手即可 --- ID + HTTP 数据包

### 9.6 更快的连接迁移

使用ID来辨别端口， 而非IP

# IP

## 1.IP的基本认识

### 1.0网络层（IP）和数据链路层（MAC）的区别

MAC ： 负责实现【直连】2个设备

IP 负责再【没有直连】的2个网络之间的通信传输

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/3.jpg" alt="IP 的作用与 MAC 的作用" style="zoom:33%;" />

其实，在网络中数据包传输中也是如此，**源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。**

### 1.1 IP地址分类

- IP地址分类

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/7.jpg" alt="IP 地址分类" style="zoom:35%;" />

  计算一个网络里面能用拥有的最大主机数， 如 C累中 2 ^8 - 2 = 254

  (因为全为1 的情况用于全体广播， 全为0指定该网络地址（不带主机）)

  - IP分类的优点

    简单明了，选路简单

  - IP分类的缺点

    ①同一个网络下没有地址层次

    ②不能很好与现实匹配（要么像C类太少，要么像B类太多）

### 1.2无分类地址 CIDR

比如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是网络号，剩余的 8 位是主机号。

- 怎么进行子网划分

  划分后的ip地址： 网络地址 +（子网网络地址 + 子网主机地址）

  如下图，假设对C类地址，中子网掩码为255.255.255.192 对其进行划分 可以得到4个子网

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/19.jpg" alt="img" style="zoom:50%;" />

  

### 1.3共有IP私有IP

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/23.jpg" alt="公有 IP 地址与私有 IP 地址" style="zoom:33%;" />

### 1.4IP地址与路由

发送IP包时，找到目标IP 与 路由表中具有相同网络地址的记录，根据该记录，jump to下一个路由器（如果有多个相同，选择相同位数最多的）

（最长匹配）

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/25.jpg" alt="IP 地址与路由控制" style="zoom: 33%;" />



路由器 `2` 收到后，同样对比自身的路由表，发现匹配到了，于是把 IP 包从路由器 `2` 的 `10.1.2.1` 这个接口出去，最终经过交换机把 IP 数据包转发到了目标主机

【特殊】 环回地址： 同一台计算机上的程序之间进行通讯的默认地址	

​				主机名localhost  :  IP : 127.0.0.1 

​				使用上述二者其一，不会将数据包流向网络

### 1.5IP分片与分组

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/26.jpg" alt="分片与重组" style="zoom:50%;" />

再分片中一旦某个分片小时，那么就会导致整个IP数据报作废，所以TCP引入了MSS进行再TCP层的分片。

### 1.6 IPV6基本认识

128位， 8 个 16位 ffff 的数字组成

- 亮点

  - 自动配置 及时没有DHCP服务器也可以实现自动分配IP
  - 包头固定值位40bytes， 去掉了 包头校验和，简化了结构
  - 有对应伪造IP地址的网络安全的功能

- IPV4 与IPV4

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/31.jpg" alt="IPv4 首部与 IPv6 首部的差异" style="zoom:50%;" />

  IPv6 相比 IPv4 的首部改进：

  - **取消了首部校验和字段。** 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。
  - **取消了分片/重新组装相关字段。** 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。
  - **取消选项字段。** 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 `40` 字节。

  

## 2.IP协议相关技术

2.1DNS

具体看第一部分的详解

2.2ARP

通过ARP请求和ARP响应 **确定MAC地址**

同时也有一整套的缓存系统再OS里，不过也带有一定的期限来缓存

- RARP

  已知MAC地址求IP地址

### 2.3DHCP

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/36.jpg" alt="DHCP 工作流程" style="zoom:50%;" />

- 客户端首先发起 **DHCP 发现报文（DHCP DISCOVER）** 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP **广播**通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。
- DHCP 服务器收到 DHCP 发现报文时，用 **DHCP 提供报文（DHCP OFFER）** 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 **IP 地址租用期**。
- 客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 **DHCP 请求报文（DHCP REQUEST**进行响应，回显配置的参数。
- 最后，服务端用 **DHCP ACK 报文**对 DHCP 请求报文进行响应，应答所要求的参数。

一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。

如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：

- 服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。
- 服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。

可以发现，DHCP 交互中，**全程都是使用 UDP 广播通信**。

**用的是UDP广播，但是不是所有客户端都和DHCP再统一局域网下，为了避免每个网络都配置一个DHCP服务器**

我们有DHCP中继代理



### 2.4NAT技术

网络地址转换， 

将每个主机对外通信时，拥有的私有IP转换位共有IP地址

可以把 IP 地址 + 端口号一起进行转换。

这样，就用一个全球 IP 地址就可以了，这种转换技术就叫**网络地址与端口转换 NAPT。**

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/39.jpg" alt="NAPT" style="zoom:50%;" />

图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进行通信，并且这两个客户端的本地端口都是 1025。

此时，**两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。**

缺陷

- 外部无法主动与NAT内部服务器建立连接， 因为NAPT没有转换记录
- 转换表生成，转换都需要性能开销
- 通信过程中，如果NAT路由重启，那么TCP连接将全部重置

solution ： ① 用IPV6， 无需NAT ② NAT穿透技术

就是客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了。

### 2.5ICMP

Internet Control Message Protocol

目的 ： 确认IP是否成功到达目标地址，报告IP包被废弃原因 和改善网络配置

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/40.jpg" alt="ICMP 目标不可达消息" style="zoom:50%;" />

- 类型

  - 处于诊断的查询信息                 【查询报文类型】
  - 处于通知出错原因的错误信息  【差错报文类型】

  

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/41.jpg" alt="常见的 ICMP 类型" style="zoom:33%;" />

### 2.6IGMP

组播地址： D类地址

那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要 `IGMP` 协议了。

工作范围： 主机 和 最后一跳的路由之间 

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/42.jpg" alt="组播模型" style="zoom:33%;" />

- IGMP报文向路由器申请加入或退出组
- 默认下路由器不会将主机主动分组
- IGMP报文由IP包装， 头部协议号位2 TTL字段位1 因为IGMP是在主机和路由器之间





工作机制：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/43.jpg" alt=" IGMP 常规查询与响应工作机制" style="zoom:50%;" />

- 常规查询和响应的工作机制

  1. 路由器会周期发送目的地址位224.0.0.1（这一网段中所有主机和路由器）IGMP常规查询报文

  2. 主机1 3 收到查询

     在【报告延迟计时器】之内，本组的一个发送 **IGMP成员关系报文** （source IP位自己主机IP 目的IP位组播 IP）  

  3. 路由器收到主机的成员关系报文后，在IGMP路由表中加入改组

- 离开组播组

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/45.jpg" alt=" IGMPv2 离开组播组工作机制 情况2" style="zoom:50%;" />

  1. 主机 1 要离开组 224.1.1.1，发送 IGMPv2 离组报文，报文的目的地址是 224.0.0.2（表示发向网段内的所有路由器）
  2. 路由器 收到该报文后，以 1 秒为间隔连续发送 IGMP 特定组查询报文（共计发送 2 个），以便确认该网络是否还有 224.1.1.1 组的其他成员。
  3. 主机 3 仍然是组 224.1.1.1 的成员，因此它立即响应这个特定组查询。路由器知道该网络中仍然存在该组播组的成员，于是继续向该网络转发 224.1.1.1 的组播数据包。

  第二补种，如果已经没有其他成员，那么就不会由响应这个查询的主机， 过来一段时间后路由器从路由表种删除这个组 的所有成员，且不会像该地址发送信息