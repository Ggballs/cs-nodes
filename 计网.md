# 1.基础

## 1.1TCP/IP模型

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="img" style="zoom: 33%;" /><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img" style="zoom:50%;" />

- 应用层

  最上层的 

  将应用数据接受或传输给下一层 （传输层）

  并专注为用户提供应用功能， HTTP FTP Telnet DNS等

- 传输层

  专门为了服务应用层，称为应用间传输媒介， 实际传输功能交给网络层

  遵循两个传输协议： TCP UDP

  - TCP

    传输控制协议（Transmission Control Protocol）
    最为常用的传输层协议 ， 比如HTTP应用层协议

    特性： 流量控制 超时重传 拥塞控制等， better than UDP

  - UDP

    比较简单  只负责传送，不保证是否抵达对方  ---> 效率高

    如果要实现可靠的传输， 将TCP特性在应用层上实现就可以

  传输过程：

  - TCP Segment

    可能会有传输数据非常大的可能， 若数据包大小超过MSS（maximum segment size) （TCP最大报文段长度）

    ​	就需要将数据包分块，这样可以分治，在某一块出问题重发该块（Segment）即可，不必重发整个数据包

  - 端口（Port）

    一个设备中为了区别多个应用的接受和传输数据  需要用一个编号来标记， --->端口 （内嵌在报文中）

    80端口for web server

    22端口for 运城登录服务器

    对于浏览器（客户端）中每个小窗口 即为一个独立进程， 操作系统会为这些进程分配临时端口号

  

- 网络层

  最常使用的协议： IP协议（Internet Protocol）

  - IP

    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="img" style="zoom: 50%;" />

    将传输层的报文作为数据部分  加上IP包头组成IP报文 

  - MTU

     最大容量为MTU（Maximum Transmission Unit)

  - IP地址

    为了区分多个设备， 我们用IP地址给设备进行编号

     （对于IPV4  一共32位 分成四段 如192.168.100.1（四段，每段8位 0 - 255））

    为了简便搜索和匹配过程， 我们将IP地址分为2种意义：网络号和主机号

    - 网络号  负责标识该IP地址属于哪个【子网】的

    - 主机号  负责标识同一【子网】下的不同主机

    - 子网掩码： 计算IP的网络号和主机号

      比如IP地址 10.100.122.0/24 

      【/24】即为子网掩码（翻译成255.255.255.0：因为前面一共24个1 ----3 * 8 ）

    - 解码过程

      IP地址与子网掩码进行一个 & 操作， 即可得到【网络号】

       		此时例子中网络号 ： 10.100.122.0

      将子网掩码取反后 与 IP地址进行 & 操作， 得到【主机号】

      ​		此时例子中主机号 ：   0.0.0.0

  - 路由

    IP协议中重要能力 

    通过很多网关、路由器、交换机、等网络设备连接起来的，

    当数据包到达一个网络节点， 就通过【网络算法】决定下一步该走的路径

    - 路由器寻址：

      找到目标地址的子网，将数据包传输到对应网络中

- 网络接口层

  MAC头部 ： 包含接收方和发送方的MAC地址信息

  通过ARP协议获取对方的MAC地址

## 1.2网页传输

### ① HTTP

- 解析URL

  确认Web服务器和文件名

  （URL构成如下：）

  - http: 开头表示访问数据的协议 + //
  - Web服务器 + /
  - 目录名 + /  （可嵌套 也可省略）

  ![image-20220629095100585](C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220629095100585.png)

  在web端的文件路径

  <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220629105059018.png" alt="image-20220629105059018" style="zoom:50%;" />

  如果URL的文件指定部分省略（即无路径名） 时：

  ​		则访问根目录下的【默认文件】 （/indx.html  或 .default.html)

- 产生HTTP请求信息

  仅仅产生了消息，下一步是确认传输对象

  ![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)



### ②DNS 真实地址查询

查询服务器域名对应的IP地址（类似通过名字查电话号码， DNS服务器则是电话簿）

- 域名组成：

​			在域名中越 **往右** 层级 **越高**（按照外国人的思维 先说小的，（街道） 再说大的（省市））

- e.g : www.server.com

  - 根 DNS 服务器（.）
  - 顶级域 DNS 服务器（.com）
  - 权威 DNS 服务器（server.com）

  跟域的DNS服务器信息 保存在互联网所有DNS服务器中 

  这样客户端只要找到Any one DNS server in the internet 就可以找到目标根域DNS server through it再一路顺藤摸瓜找到下层的某台目标服务器。

- 域名解析流程

  - 客户端发出DNS请求， 问www.server.com 的IP是多少 发给本地DNS服务器（客户端TCP/IP设置中写的DNS服务器地址）

  - 本地的DNS服务器收到请求后

    ​	如果缓存里有www.server.com

    ​			则直接返回其IP

    ​	else 

    ​			去根域名服务器请求

  - 根DNS收到本地DNS请求后

    发给本地DNS    .com顶级域名服务器地址

  - 本地DNS继续向.com DNS服务器发送请求

  - .com DNS服务器 找到www.server.com 的权威DNS服务器 给本地DNS

  - 本地DNS向权威DNS服务器询问

  - 权威DNS服务器查询后将对应地址告诉本地DNS

  - 最后  本地DSNS将IP地址传给客户端  完成连接

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" alt="域名解析的工作流程" style="zoom:50%;" />

  - 缓存：

    为了节省寻址时间，在每次寻址结束后，都会备份IP地址在缓存里，寻址的缓存优先级依次为

    - 浏览器本身缓存
    - 操作系统缓存
    - hosts文件

    都没有才会去找DNS服务器

    

### ③协议栈

负责HTTP内容的传输工作

栈中上下关系有一定规则的， 上面部分给下面部分委托工作， 下面部分接受并执行

下面是整个工作的层级关系  和 协议栈内部的层级关系

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="img" style="zoom:50%;" />

- 栈的组成

  - 第一层： UDP TCP

    负责接受应用层的委托执行收发数据的操作

  - 第二层 IP

    负责网络包的手法操作

    * ICMP  告知网络包在传输过程中的产生的错误和各种错误
    * ARP    根据IP查询以太网的MAC地址

- 工作流程

  - 浏览器调用socket库 委托协议栈工作
  - 协议栈先通过UDP TCP对数据进行收发工作
  - 通过IP协议控制网络包
  - 网卡驱动负责控制网卡
  - 网卡负责完成实际的收发工作（网线中的信号执行发送和接受操作）

### ④可靠传输TCP

- TCP包头格式

  （以下为HTTP数据版本， 如果更general 一些，则把HTTP报文改为数据板块即可）

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg" alt="TCP 层报文" style="zoom:50%;" />

  【序号】：解决包乱序的问题

  【确认号】：目的确认发出去对方事发后收到。如果没有收到就重新发送，直到送达

  【状态位】： 有些带状态位的包的发送，会引起双方的状态改变

  - SYN： 发起一个连接
  - ACK： 回复
  - RST： 重新连接
  - FIN： 结束连接

  【窗口大小】：（缓存大小） 标识自己当前能够处理信息的能力

  ​							目的：做到流量控制（刚刚好，别太多，别太少， 根据缓存大小）

  

- 传输过程

  - 三次握手

    （传输数据之前） 需要TCP建立连接 between 客户端 and 服务端

    - 一开始 客户端服务端都处于`closed`状态
    - 服务端主动监听某个端口  处于`Listen` 状态
    - 客户端主动发起连接SYN， 处于`SYN-Sent`状态
    - 服务端收到连接请求， ①返回SYN，②并且ACK客户端的`SYN` 处于 `SYN-RCVD`状态
    - 客户端收到服务端的SYN和ACK后 发送对SYN确认的ACK 之后处于`ESTABLISHED`状态
    - 服务端收到ACK的ACK后 处于`ESTABLISHED`状态
    
    所以三次握手的目的 **保证双方都有发送和接受的能力**
    
  - TCP分割数据‘
  
    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg" alt="MTU 与 MSS" style="zoom:67%;" />
  
    如果HTTP请求信息过长 超出【MSS】长度 这时TCP需要把请求数据拆解成一个个数据块发送
  
    并在每一个数据块添加TCP头部
  
    再往后就都一样 添加IP头部 MAC头部
  
  - TCP报文生成
  
    协议中有2个端口 
  
    ①浏览器监听端口（随机产生）
  
    ②Web服务器监听端口（HTTP默认 80， HTTPS默认443）
  
    - 报文组成
  
      HTTP头部+ 数据



### ⑤远程定位IP

Iternet Protocol address

每一个网络 每一个主机都有一个唯一的逻辑地址

（用来与物理地址相区分）

- IP包头格式

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg" alt="IP 包头格式" style="zoom:50%;" />

  因为数据（HTTP）是经过TCP传输的，所以在IP包头的协议号， 要填写为【06】（十六进制） 表示协议为TCP

  【源IP】 客户端输出IP

  【目标IP】 通过DNS得到的Web 服务器IP

  - 客户端多个网卡情况（多个IP）

    通过路由表规则 判断哪一块网卡作为source IP

    <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220630110220982.png" alt="image-20220630110220982" style="zoom:67%;" />

    比如web 服务器IP（目标IP）为196.168.10.200

    ①先与子网掩码（Genmask）求&  得到网络号 ： 192.168.10.0 

    ②与路由表中的Destination匹配 （图中得到 为第二排， 对应的Iface 为eth1）

    所以最终得到的source IP为eth1

    【默认网关】

    在图中为第三排 Destination 和Genmask都为0

    就是当所有其他条目都无法匹配，就会自动匹配这一行，并把包发给路由器（Gateway即路由器的IP第地址）

- IP报文生成

  source IP

  Destination IP

  协议（Protocol） 为0x06

### ⑥两点传输MAC

Media Access Control address 

可以称为局域网地址，

- MAC包头格式

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg" alt="MAC 包头格式" style="zoom:50%;" />

  一般在TCP/IP通信中 MAC包头的Protocol 类型只有

  - 0x  0800： IP协议
  - 0x  0806： ARP协议

  发送方：读取网卡ROM里的存储的自己的MAC地址即可

  接收方：

  - 查询【路由表】  在表中找到相匹配的条目， 把包发给Gateway列的IP地址
  - 根据IP找到MAC地址
  - ARP协议：
    - 在ARP缓存内查询是否有对应的MAC地址
    - 在Internet中发出广播寻址

- 生成MAC报文

  至此 网络包总览如下：

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg" alt="MAC 层报文" style="zoom:50%;" />



### ⑦出口 网卡

目的： 将数字信息转换为电信号

操作：网卡

控制：网卡驱动

过程：

- 复制网络包到网卡的Cache中
- 在开头加上报头和起始帧分界符
- 末尾加上用于错误检测的帧校验序列 （Failure Censor Sequence）

### ⑧交换机

仅仅在MAC层进行操作

基于以太网设计的（俗称二层网络设备）  端口不具备MAC地址

- 包接收

  - 电信号到达网线接口  交换机里模块进行接受  

  - 模块将电信号转换为数字信号

  - 通过包末尾的【FCS】校验错误  没错则放到缓冲区（buffer）

    - 交换机端口不核对接收方MAC地址 而是直接把接受的所有网包都放入buffer
    - 判断接收方MAC地址的功能在网卡上
    - 交换机端口不具有MAC地址

  - 查询这个包的接收方MAC地址是否在【MAC表】中有记录 并发送到对应端口

    - 【MAC表】

      - 设备的MAC地址
      - 该设备连接在哪个端口上

      有多行数据

      <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220630113917116.png" alt="image-20220630113917116" style="zoom:53%;" />

    - 【MAC表】中五对应的MAC地址时

      ①将包转发到除了source Port的**全部端口**上

      （因为以太网的设计本来就是将包发送到整个网络的，然后**只有相应的接收者才接收包，而其他设备则会忽略这个包**。）

      ②如果接收到了响应包（对应端口接受了网包并向交换机回应响应包）

      ​	则会将他的MAC地址写入MAC地址表，以更新



### ⑧出境大门 路由器

经过交换机后 到达了路由器

* 路由器基本原理

  基于IP设计的 （三层网络设备）

  每个端口都有MAC地址和IP地址

  MAC地址：所以可以作为Internet的发送方和接收方

  IP地址：     同时有这2个地址从这个意义上说，与PC的网卡是一样的

  - 转发包

    路由器端口接收发给自己的Internet 网包，

     由路由表查询转发目

    向对应端口作为发送方将Internet 网包发送出去

* 包接受操作

  路由器中的一模块将端口的电信号转换为数字信号   并通过包末尾的【FCS】校验错误

  没错误就检查MAC头部的接收方MAC地址是否是自己

  （ **每一个路由器端口都有自己的MAC地址**）  

  是自己的就将其放入buffer

  else 丢弃

* 查询路由表确认输出端口

  与上面的IP处的路由表操作一样

  如果找不到匹配路由时，就会选择默认路由（Genmask = 0.0.0.0 的记录）

* 发送包操作

  ①根据路由表中的【网关列】（Gateway）判断对方的IP地址

  - IP 说明 **还没抵达终点** 还需路由器转发
  - 空  说明已经到达终点 已经找到了IP包头里的目标地址

  ②通过【ARP】协议 查询MAC地址  ，将结果作为接收方的MAC地址

  ③生成新的MAC头部

  修改发送方的地址字段为 路由器的输出端口MAC

  修改协议字段为0x 0800（IP 协议）

  ④将其转换为电信号通过端口发送

  ⑤通过交换机到达下一个路由器

**过程中 Source IP 和Destination IP永恒不变， 只有MAC地址在变**

### ⑨扒皮过程， 服务端和客户端

服务器：

- 先匹配MAC头部

- 匹配IP头部

  - 匹配IP地址
  - 查看上层协议 （一般为TCP）

- 根据上层协议匹配（匹配TCP头部）

  - 匹配序列号

    如果是需要的就放入buffer 然后返回一个【ACK】

    else 就丢弃

  - 端口号

    HTTP的服务器正在监听这个端口号

    将包发给HTTP进程

- 服务器的HTTP进程

  看到请求内容

  如果是请求访问一个页面 那么就会把网页封装在 HTTP响应报文里

  擦换啊很难过TCP IP MAC头部 发往客户端

  （经过网卡  交换机  路由器  路由器。。。 交换机， 网卡）

- 客户端

  扒皮 只剩下HTTP响应报文后 交给浏览器去渲染页面

  离开  向服务器发起TCP四次挥手  

  连接断开



# 2.HTTP

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg" alt="HTTP 的消息格式" style="zoom:33%;" />

## 2.1 基本概念

超文本传输协议（HyperText Transfer Protocol)

在计算机世界里在 【两点】之间【传输】【超文本】数据的【Protocol】

（判断 ： HTTP用于INTERNET Server ---> Local Server 【×】 cuz：可以是两点之间"INTERNET Server  <----> Local Server"

- Protocol

  确认各种控制和错误处理方式 的 **行为约定和规范**；

- transfer

  HTTP是一个**双向协议 **   **两点之间传输数据**的约定和规范

  - 基本过程

    浏览器（客户端） 向百度网站（服务端） 申请一个数据访问请求，

    服务端将数据返回给浏览器

    浏览器进行渲染在屏幕上

  - 中转与接力

    只要中间人遵循 HTTP 协议， 不打扰基本的额数据传输

    **就可以任意添加额外的东西**

- HyperText

  - 文本：

    目前已经可以扩展为 图片， 视频， 压缩包等

  - 超文本

    文字图片视频的混合体  **最关键有超链接** 从一个超文本跳到另外一个超文本

    （E.g: HTML ： 本身只是纯文字文件， 但是内部有很多标签定义的图片视频的LINK， 

    ​			经过浏览器的解释和渲染，就可以获得一个有文字和图片的网页了）



### 2.1.1 HTTP 状态码

| 具体含义                                                     | 常见状态        |
| ------------------------------------------------------------ | --------------- |
| 1** ： 提示， 目前处于中间态，还需后续操作                   |                 |
| 2**：  成功， 报文已被成功收到并处理                         | 200 204 206     |
| 3**：   重定向，资源位置发生变动，需要客户端重新发送请求（like ？ABORT） | 301 302 304     |
| 4**：   客户端错误，请求报文有误， Server 无法处理           | 400 403 404     |
| 5**：  服务器错误，在处理请求时发生错误                      | 500 501 502 503 |

- 1** 应用较少
- 2** 成功处理客户端的请求
  - 【200 OK】 一切正常 且返回的响应头有body数据
  - 【204 No Content】 与200相同，但是没有body数据
  - 【206 Partial Content】 应用于HTTP **分块** 下载和断电传输， 表示一部分ok
- 3**  redirection
- 4** error context  from client is wrong;
  - 400 bad request
  - 403 forbidden
  - 404 Not Found

- 5** error in web server

​	

### 2.1.2常见字段

- Host

  指定服务器的域名

  [e.g] : www.A.com

- COntent--Length

  回应数据的长度（一般单位为Byte）

  [e.g] : 1000

- Connection

  连接状态（HTTP/1.1 版本默认都是持久连接）

  为了兼容老版本的HTTP 

  ```http
  Connection: keep-alive	
  ```

  可复用的TCP连接，Till 客户端or 服务端主动关闭连接， **这不是标准字段**

- Content Type

  ```http
  Content-Type: text/html; charset=utf-8
  ```

  发送的是网页

  编码为UTF-8

  

  客户端请求时，可以根据需求声明自己接受那些数据格式

  ```http
  Accept: */*
  ```

  表示接受全部， /前的为网页数据格式，

  ​							/后的为编码格式

- Content-Encoding

  表示压缩的格式

  ```http
  Content-Encoding :gzip
  ```

  常见有 gzip， deflate
  
  请求时客户端也可以声明接受的解压方式
  
  ```http
  Accept-Encoding: gzip, deflate
  ```
  
  



## 2.2GET ,POST

这来就是常见的http头部的 Method 

【**以下均从RFC规范定义**】 出发  

- GET

  - 资源  静态的文本 页面  图片视频等
  - HTTP版本
  - 参数位置  URL 

  从服务器获取指定的资源 

- POST

  - 处理方式   e.g :/submit
  - HTTP版本
  - 参数位置 URL

  根据请求符合（报文的BODY） 对指定的资源做出处理

  比如申请写一段留言   那么就会社区宁在网页的body 部分书写一些东西

- GET POST 方法都安全 和幂等吗

  - 安全

    请求方法不会破坏服务器上的资源

  GET 安全且幂等  因为是【只读】动作        （所以可以对GET进行缓存到浏览器上  也可以存为书签）

  POST  会修改服务器的资源  所以是【不安全】的

  ​             且多次提交就会创建多个资源  所以是【不幂等】的

  不可被缓存



## 2.3 HTTP缓存技术

目的 ： 为了加速网页浏览的速度

- 强制缓存

  只要浏览器判断缓存没有国企  那么就直接使用浏览器的本地缓存   （属于是浏览器的【强制缓存】）

  一般会在Status Code 后的size 项中标明（ **from disk cache** )

  - 有效期

    利用HTTP响应头部（response Header）

    - Cache-Control 相对时间
    - Expires  绝对时间

    

  - 使用Cache-Control 缓存的流程

    - browser 第一次申请访问服务器资源时， 服务器会返回这个资源同时 ，在Response Header 加上 Cache-Control  里面设置【保质期】

    - 再次访问服务器的该资源时  会先通过比较 是否过期  来决定是否使用缓存 或者重新请求服务器

    - 如果服务器再次收到请求， 

      - 如果资源 没更新 那么服务器返回304 Status Code
      - 如果更新了 并成功传回新的页面， 返回200 Code

      会更新Response 头部的Cache-Control

  - 优先级

    如果同时这2个头部  那么Cache Control 的优先级 高于 Expires

- 协商缓存

  响应码时 `304` 代表告诉浏览器 可以使用本地缓存的资源  【服务器告诉客户端是否可以使用缓存】  叫做协商缓存

  即是发现本地的缓存已经过期  向服务器发送更新请求时 服务器发现资源并未更新  就返回304 code  

  可以基于2种头部实现

  第一种

  - 响应头部中的 `Last-Modified` 标识 响应资源的最后修改时间

  - 请求头部中的 `If-Modified-Since`当资源过期了， 发现缓存中有`Last-Modified` 声明，才使用该方法

     客户端发起请求时会发送 带有 Last-Modified  时间  服务器比对看是否需要更新

  第二种：

  - 响应头部的`Etag` 唯一标识响应资源
  - 请求头部中的 `If-None-Match` 过期资源中发现存在 `Etag` 则向服务器发送请求时 将 `If-None-Match`  值设为ETag的字段， 服务器比对，如果变化则更新并返回200

  相对而言后者基于唯一标识实现 会更保险， 避免了由于时间篡改而导致的不可靠问题

  优先级

   Etag  >  Last-Modified 如果Etag没有变化 再看Last-Modified

## 2.4HTTP（1.1）特性

- 优点

  - 简单

    header + body 

  - 灵活和易于扩展

    Method URI/URL Status Code  Header 等每个组成都没有被要求固定死  都允许developer 自定义或补充

    同时HTTP工作在应用层（OSI第七层）则她的【下层可以随意变化】

  - 应用广泛 跨平台

    台式机 到手机上的各种APP 且游戏新闻购物都有应用

- 缺点

  - 无状态双刃剑

    - pro 不会记忆HTTP状态  减少服务器负担 减少CPU跟内存的调动

    - con 服务器没有记忆能力， 完成有关联性的操作会比较麻烦

      - eg ： 登录---> 添加购物车 --> 下单--> 支付   每一个过程都需要知道用户身份才行， 但是服务器并不知道这些有关联，必须每次问一次身份信息

      - solution： `Cookie`

        第一次请求后， 服务器返回一个Cookie （小贴纸）

        第二次以后请求带上Cookie 即可轻松让服务器识别身份

  - 明文传输双刃剑

    - pro 便利性
    - con 不安全

  - 不安全

    - 明文传输  内容可能会被窃听
    - 不验证通信放身份， 可能会遭遇伪装网站  e.g 假淘宝拼多多
    - 无法证明报文完整性  所以有可能已经遭篡改 e.g 网页植入的垃圾广告

    solution ：HTTPs 引入SSL/TLS层 安全上达到了极致



## 2.5HTTP/1.1 性能

①长连接

减少了TCP来凝结的重复建立和断开 导致的 额外开销

只要任意一端没有明确提出断开连接， 则一直保持TCP连接转台

（不过如果HTTP在超过一定时间没有数据交互， 则主动断开这个连接）

② 管道网络传输

因为长连接的存在，可以使（pipeline）传输称为可能

定义： 在同一个TCP连接里，可以发送多个请求，只要有第一个请求发送出去，不必等其回来，第二个就能发出， 减少响应时间

（以前是等待前一个请求回应接受到了才能发出第二个请求）

③队头阻塞

如果前面的请求因为某种原因阻塞， 那么后面也一同被阻塞， （类似赛车）



## 2.6 HTTPS 与HTTPS

### 2.6.1区别

- HTTPS解决HTTP里的不安全缺陷 ， 在TCP和HTTP层增加 SSL/TLS安全协议 使得报文能够加密传输
- 建立过程
  - HTTP连接建立简单， TCP三次握手之后即可进行HTTP传输报文
  - HTTPS在TCP三次握手之后，还要进行SSL/TLS 握手过程 才能进行加密报文传输
- HTTP端口号为80  HTTPS 端口号443
- HTTPS需要向CA（certificate Authority） 社区宁数字证书，to prove the id of server is reliable

### 2.6.2 HTTPS解决了哪些问题

- 窃听 加密报文
- 篡改  通过校验机制，无法篡改通信内容         避免强行植入垃圾广告  但是百度还是可以自己发
- 冒充 有CA的证明

方法：

- 混合加密   保证信息的机密性

  - 非对称加密 ： 

    在通信建立前采用， **交换**【会话密钥】 后续不再i使用非对称加密

    特点： 使用2个密钥（共和私， 公钥可以随意分发，而私钥保密，解决交换问题 但是速度慢）

  - 对称加密

    在通信过程中全过程使用对称加密的【会话密钥】的方式 **加密** 与**解密**明文数据

    <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220809111621718.png" alt="image-20220809111621718" style="zoom:59%;" />

- 摘要算法 + 数字签名 实现完整性 （为数据生成独一无二的【指纹】 校验数据完整性）

  摘要算法：

  通过哈希函数来计算出内容的哈希值， （唯一，且无法通过哈希值推导出内容）

  - ①server 将 content 和哈希值A 一起发送
  - ②client 通过哈希计算重新算出哈希值B 并与A比对， 检验完整性
  - 问题： 无法避免【内容+哈希值】不会被中间人替换
  - 解决 ： 非对称加密算法

  非对称加密：（均可加/解密）

  - 公钥 给所有人
  - 私钥  必须本人管理， 不可泄漏

  第一种： 

  公钥加密， 私钥解密 ： 保证内容传输安全，

  第二种：

  私钥加密， 公钥解密 ： 保证消息不被冒充 

  - trade off
  - 一般不会用非对称加密算法来加密实际的content （比较耗时）， 所以一般只用第二种， 确认消息身份 **数字签名算法**

  算法： 私钥encode 内容的哈希值， 给到client ，用公钥来解密数字签名为哈希值A， 后再比对哈希值AB

  <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220809112252403.png" alt="image-20220809112252403" style="zoom:50%;" />

- 将server公钥放入数字整数中，解决冒充风险

  避免公钥被伪造

  所以出现权威的CA来存储并认证公钥和域名



### 2.6.3HTTPS的TLS握手

- SSL/TLS 协议过程

  - 客户端向服务器索要并验证服务器公钥

  - 双方协商生产【会话密钥】

    （前两部为SSL/TLS 建立过程 【握手】阶段  涉及 【4次】通信， 基于RSA 的握手过程如下：

    （Secure  Socket Layer / Transport layer sucurity)

    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="HTTPS 连接建立过程" style="zoom:45%;" />

    0.  三次握手

     ①ClientHello

    ​			客户端向服务器发起加密通信请求，主要信息包括  

    - 客户端支持的SSL/TLS 协议版本， 如TLS1.2
    - 客户端生成的随机数【Client Random】， 后面用于生成【会话密钥】的条件之一
    - 客户端的密码套件列表 如（RSA加密算法）

    ②ServerHello

    成功接受请求后， 先发送一个ASK 后发出响应个欸客户端 包含如下内容

    - 确认SSL/TSL版本 如果浏览器不支持，则关闭通信
    - 生成随机数【Server Random】
    - 确认密码套件列表，
    - 服务器的数字证书（client 收到证书后利用os里的CA公钥验证证书并取出服务器的公钥）
    - 发送hello done

    ③客户端回应

    回ASK后， 通过浏览器或OS中的CA公钥， 确认服务器的整数的真实性

    如果无问题  那么客户端取出服务器的公钥， 加密报文，向服务器发送

    - 随机数【pre-master key】 （利用公钥加密， 服务器自身利用自己的私钥解密）
    - 做出通知 ： 表示加密同行之后都将会用【会话密钥】进行通信（此时第一次刚好拥有3原件 可以组成会话密钥）
    - 客户端握手结束通知  并将之前发声的所有数据做个摘要， 提供服务端**校验**

    ④服务器的最后回应

    通过【pre-master key】，经过协商的加密算法 计算出本次的【会话密钥】

    然后发出

    - 做出通知： 接下来的信息会用【会话密钥】进行加密
    - 将之前发声的所有数据做个摘要， 供**校对**

    

  - 接下来都采用会话密钥通信

### 2.6.4HTTPS应用数据如何保证完整性

TLS分为

- 握手协议

  TLS四次握手过程 协商加密算法和堆成密钥

- 记录协议

  保护应用程序数据完整性和来源 （在利用密钥加密时，使用此协议）

记录协议负责 ① 消息（HTTP数据） 压缩，加密 认证

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png" alt="img" style="zoom:30%;" />

- 消息被分割成多个片段  并进行压缩
- 在压缩片段后加上【消息认证码】MAC值（通过哈希算法生成） ----for 保证完整性的数据验证
- 一起合并后，通过【会话密钥】进行加密
- 最后加上报头  包含数据类型， 版本号， 压缩密文的长度

### 2.6.5可优化部分



## 2.7 HTTP/1.1 2.0 3.0 的变化

### 2.7.1HTTP/1.1

相较。1.0 改进

- 利用pipeline网络传输， 减少整体响应时间
- 利用长连接， 减少不必要的通信开销

存在的瓶颈：

- Header 未经压缩就发送  且每次都发送相同的也没有优化
- 队头阻塞：  按照请求顺序响应， 前面有未完成的，那么后面都无法开始、
- 请求只能从客户端开始， 服务器只能被动响应

如何优化：

- ①避免发送HTTP请求
- ②必须发送时， 减少发送次数
- ③减少Server 的HTTP响应的数据大小

①通过缓存避免发送HTTP请求

②减少发送次数

- 减少重定向请求次数

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img" style="zoom:33%;" />

  将重定向的工作分给代理服务器来做

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img" style="zoom:33%;" />

  如果代理服务器已经知道了重定向的地址（规则） 那么就又可以省略代理服务器 ---> 源服务器（url1 与源服务器302的response） 的一步来回， 直接发送/url2  源服务器返回200 资源2；

- 合并请求

  把多个小的请求合并为一个大的HTTP资源请求

  好处： 

  - ①减少了HTTP头部的重复发送

  （且以你为HTTP/1.1为请求响应模型， 会产生【队头阻塞】 每个请求都会造成一次TCP连接）

  - ②如果合并了请求，那么也就减少了TCP连接的数量，因此省去了TCP握手和慢启动过程耗费的时间

  例子

  - 网页的很多小图标， 小图片 合并成一个大图片（利用 【CSS Image Sprites】）， 再根据CSS数据把大图片分割成小图片
  - Server 端，用【webpack】等打包工具，将js，css等资源合并打包成大文件

- 延迟发送请求

  【按需获取】，当用户滑到相应位置，再向服务器获取接下来的资源

③通过【压缩】 减少响应数据大小

- 无损压缩

  gzip ：

- 有损压缩

  可以通过Header中的Accept 字段里的【q质量因子】来告诉服务器期望的资源质量

  



### 2.7.2 HTTP/2

基于的时HTTPS  所以HTTP/2也有安全保障

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png" alt="HTT/1 ~ HTTP/2" style="zoom:50%;" />

- 头部压缩

  如果发送多个请求 且 头部一样或相似， 那么会消除重复的部分

  （即 **HPACK**算法 ： Client 和Server 共同维护一张 Header信息表， 所有字段都存入这个表，生成索引号， 这样就减少了发送的耗损）

  - 静态表编码

    1-61个最常用的字符串

    - ​	用index 标记， 省去长字符串所耗费的字节成本
    - ​    用Huffman压缩发压缩

    第一个字节为01 + index（6个bit） 第一部分代表是否为定值  第二个部分为index

    第二个字节为0/1 (是否为Huffman加密）+value length 

  - 动态表编码

    从62开始

- 二进制格式

  Header 和body 全面使用二进制， 统称为帧（frame）

  方便机器传输和解析， 无需进行中间报文的encoding 和decoding  增加效率

- 数据流

  因为数据包不是按照顺序发送的  所以必须对数据包进行暴击

  ​                   定义： 每个请求或回应的所有数据包 被称为一个数据流（stream） 每个数据流都有一个【steam ID】 

  因此可以实现【并发发送】

  ​                   区别：客户端建立的必须是奇数号， 服务器偶数好

  ​                   优势 ： 客户端还能指定数据流的优先级， 优先级高的，服务器先响应

- 多路复用

  可以并发多个请求和回应， 解决【队头阻塞】 降低延迟  提高连接利用率

- 服务器推送

  解决服务器被动地位， 可以主动向客户端发送信息

  <img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220810075005335.png" alt="image-20220810075005335" style="zoom:50%;" />

  比如可以主动发出CSS文件， 减少消息传递次数

缺陷 ：

- 还是存在【队头阻塞】问题，只不过实在TCP这一层

  多个请求复用一个TCP连接解决了HTTP队头阻塞问题， 但是一旦丢包，就会阻塞所有HTTP请求，即客户端无法收到丢包后的所有包

### 2.7.3 HTTP/3

<img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220810075248267.png" alt="image-20220810075248267" style="zoom:50%;" />

因为HTTP/2 的TCP层队头阻塞问题， HTTP/3 使用了UDP（不可靠传输） 但是基于【QUIC】协议， 一样可以所hi先类似TCP的可靠性传输

QUIC 的特性：

- 无队头阻塞

  多路复用 同一个Link 并发多个Stream

  而且保证可靠性： 当某个stream发声丢包时， 只会阻塞这个流， 其他流不受影响， 不触发队头阻塞问题

- 更快的连接能力

  QUIC三次握手即可开始传输 不需要TLS握手

- 连接迁移

  在TCP中 通过四元组（源IP，源port 目的IP， 目的port） 确定一条TCP连接， 那么移动设备从流量变成WIFI时 IP发声了变化， 那么必须重新建立连接

  此时就必须重新【3此握手加TLS四次握手】的时延，一起TCP的慢启动减速过程

  解决：

  QUIC协议中 没有四元组， 通过 【连接ID】 来标记通信2个端点，因此即使IP变了， 只要保留有上下文（context） 信息（连接ID， TLS密钥）等，就可以无缝复用原链接， 消除重连成本。  



 

# TCP

## 1.基本认识

### 1.1 TCP 头部

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn?x-oss-process=image/format,png" alt="TCP 头格式" style="zoom:50%;" />

【序列号】在建立连接时由计算机生成的随机数为初始值。 通过SYN包传给接收端主机，每发送一次就【累加】一次该【数据字节数】大小。 解决网络包乱序问题

【确认应答号】 下一次【期望】收到的数据的序列号，发送端收到这个确认应答后， 可以认为这个序列号之前按的数据都已经被正常接受。解决丢包问题

【控制位】

- *ACK*：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
- *RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
- *SYN*：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。

### 1.2TCP工作

**产生原因**：

解决IP传输的不可靠性。

**工作区层**：传输层

**特性**：

能保证传输的可靠数据传输服务，能保证接受的网络包时【无损坏】【非冗余】【无间隔】【按序】

TCP传输时具有

- 每个消息分组

- 每个消息的报文边界  保证完整性
- 对于重复的包选择丢弃 【无冗余】
- 按照顺序读取，即使属于后面的包被接收到了，但队头的包未被读取到，也无法读取后面的。

**属性**：

TCP是【面向连接】的，【可靠的】，基于【字节流】的传输层通信协议。

- 面向连接： 一定是【一对一】连接，且基于双方认可

  （UDP一对多）

- 可靠性。 ：无论链路层发声什么链路变化， TCP都能保证一个报文达到接收端

- 字节流。 

**定义**

【连接】

用于保证可靠性和流量控制 维护的某些状态信息（Socketssquence, numbers, window sizes)

实际上在TCP中，我们需要

- 源地址IP（IP头部） 32位  通过IP协议发送给主机
- 目标地址IP
- 源端口地址（TCP头部）16位 通过TCP协议发送给哪个进程
- 目标端口地址

四元组，作为唯一确认的连接

TCP最大连接数也和此2个有关 = 客户端IP数 * 客户端端口数

（e.g IPV4 ： IP最多 2的32次方  端口数最多2的16次方  乘一起 2 的48次方）

而实际难以达到理论上线，会受到如下因素印象：

- 文件描述符限制 ：每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：
- 内存限制

## 2.与UDP区别

- UDP

  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEyLmpwZw?x-oss-process=image/format,png" alt="UDP 头部格式" style="zoom:50%;" />

  利用IP提供面向【无连接】的通信服务

  - 端口号 决定发送给哪个进程
  - 包长度 保存了UDP首部的长度和数据的长度之和
  - 校验和 防止收到受损或收更改的UDP包

区别

- 连接

  TCP面向连接

  UDP不需要连接， 即可传输数据

- 服务对象

  TCP 一对一

  UDP一对多，多对多都可以

- 可靠性

  TCP > UDP

- 拥塞控制，流量控制：

  TCP有拥塞控制和流量控制，保证数据传输的安全性

  UDP则没有， 即使网络非常拥堵也**不会影响**UDP传输速度

- 首部开销

  TCP(没有使用【选项】时为20Bytes) > UDP(8 bytes 固定不变)

- 传输方式

  TCP是数据流传输， 没有边界， 但有确保边界的信息 和确保顺序可靠

  UDP是一个包一个包的发送，有边界，但可能丢包或乱序

- 分片

  TCP会根据MSS（maximum segment size） 在传输层进行分片。如果丢了一个片，那么只需要重新传输这个分片即可

  UDP数据包如果大于MTU（maximum transition unit）大小则在IP层分片

- 应用场景：

  TCP 保证可靠向， 以及面向连接

  - FTP文件传输
  - HTTP/HTTPS

  UDP 随时传送数据， 且简单高效

  - 包总量较小的通信： DNS，SNMP
  - 视频， 音频
  - 广播

### 2.1为何TCP没有包长度

TCP数据长度 = IP总长度 - IP首部长度- TCP首部长度（前2在IP头部可查， 后者在TCP头部可查）

UDP其实也可以这么算，但是可能为了不全首部长度为【4bytes】整数倍， 不全了包长度

