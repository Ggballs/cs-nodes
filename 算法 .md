# Basics
## 数组

```c++
int Getsize(int data[]){
    return sizeof(data);//sizeof int*
}
int main(void){
    int array[]={1,2,3,4,5};
    int size1= sizeof array;//the size of array in bytes
    int *ptr1=array;
    int size2=sizeof ptr1;//sizeof int*
    int size3=Getsize(array);	
    cout<<size1<<'|'<<size2<<'|'<<size3;//result：“20|8|8“；in 64bit sys;(if in 32', 8->4;)
    return 0;
}
```

* 任何一个空的类型 （class）sizeof之后都是1；
* 指针都是根据计算机系统的位数来决定的  64---8byte
* sizeof 识别数组名优先级大于识别指针 ，所以此时array的大小为20，每个int为4字节
* 数组名传入function（）中后 ，识别为指针。

删除元素

双指针做法

## 循环数组的处理

可以使1个数组变成2个数组，再进行遍历操作。

如：下一个更大元素Ⅱ就可以使用此方法。

**或在遍历时遍历2倍数组大小，再在下标处%size**

```c++
for (int i = 0; i < nums.size() * 2; i++) {
            // 模拟遍历两边nums，注意一下都是用i % nums.size()来操作
            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {
                result[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }
```

或者判断s是否为反转的数组or字符串也可以这样，将s  +  s 即可（补在后面）  看2s是否contain 原来的字符串或数组（与之匹配）

# Hashtable

unordered_set / unordered_map  O(1) O(1);

map / set /multiset / multimap O(logN)  O(logN);

找到组成一样的比如说单词

先sort 再 存入hash中，

[字母异位词](https://leetcode.cn/problems/group-anagrams/)

## 原地哈希

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0; i < n; i ++){
            if(nums[i]  == i) continue;
            while(nums[i] != i){
                if(nums[nums[i]]  == nums[i]) return  nums[i];
                swap(nums[i], nums[nums[i]]);
            }
        }
        return -1;
    }
};
```

将所有的元素放在nums[i] == i 的地方



#   Stack

## 	1.2个stack构成一个queue

①staack_buffer 

 ②stack _print 

buffer栈是用于push（）的

print栈用于pop（）

其中关系在于每次如果print栈空了 就把buffer栈的元素push进print并pop直至empty



## 	2.包含min函数的栈

2个栈 ①stack_buffer②stack_min;

对应关系 ：

每个buffer栈里的元素 同样位置于min栈里都有对应此时最小的元素

​	实现 ：每次push（）时  取**min(val,stack_min.top())**push进stack_min() 中

pop（）：2个栈同时pop（）

min（）：return stack_min.top()；

## 计算器

完全解决所有类型的表达式计算

- 括号
- 优先级

利用2 个栈 

- nums 优先使用long  为了维护可能存在的大数运算
- op 运算符

①维护优先级

- 利用unordered_map<char,int> 来记录优先级

​	**【栈内运算符】比 【当前运算符】 高级或同级 才能运算**

​	运算到直到遇到

- 无运算符
- 左括号（在目前符号为右括号时）

才停止

> 因为我们是从前往后做的，假设我们当前已经扫描到 2 + 1 了（此时栈内的操作为 + ）。
>
> 如果后面出现的 + 2 或者 - 1 的话，满足「栈内运算符」比「当前运算符」优先级高/同等，可以将 2 + 1 算掉，把结果放到 nums 中；
> 	如果后面出现的是 * 2 或者 / 1 的话，不满足「栈内运算符」比「当前运算符」优先级高/同等，这时候不能计算 2 + 1。

为了避免连续出现的符号把 (-  --> ( 0 -    把 (+ --> ( 0 +

为了避免边界判断  第一个数字可能时负数 所以可以在nums 里先加一个0

```c++
class Solution {
public:
    unordered_map<char,int> prio = {
        {'+', 0},
        {'-', 0},
        {'*', 1},
        {'/', 1}
    };
    int calculate(string s) {
        stack<long> num;
        stack<char> op;
        long curnum = 0;
        num.emplace(0);
        for(char ch : s){
            if(ch == ' ')continue;
            if(isdigit(ch)){
                curnum = curnum * 10 + ch - '0';
            }
            else if(ch == '('){
                op.emplace(ch);
            }
            else if(ch == ')'){
                num.emplace(curnum);
                curnum = 0;
                while(op.size() && op.top() != '('){
                    cal(num,op);
                }   
                op.pop();
                curnum = num.top();
                num.pop();
            }
            else {
                num.emplace(curnum);
                curnum = 0;
                while(op.size() && op.top() != '(' && prio[op.top()] >= prio[ch]){
                    cal(num, op);
                }
                op.emplace(ch);
            }
        }
        num.emplace(curnum);
        while(op.size()){
            cal(num,op);
        }
        return num.top();
    }
    void cal(stack<long> &num, stack<char> &op){
        if(num.empty() || num.size() < 2) return;
        long a = num.top(); num.pop();
        long &b = num.top();
        char ch = op.top(); op.pop();
        switch(ch){
            case '+' : b = b + a; break;
            case '-' : b = b - a; break;
            case '*' : b = b * a; break;
            case '/' : b = b / a; break;
            default : break;
        }
    }
};
```



## 3.单调栈

类似（最大值queue的class 剑指offer题（利用deque 和 queue完成）

性质  从栈顶到栈底的元素是严格单调的

应用场景：

需要要找2边（1边）比cur 大（小） 的值 可以用

下一个更大的数字

### [**接雨水**！](https://leetcode-cn.com/problems/trapping-rain-water/)

初始处理；

​	找到第一个 “下一个元素比自己更小的”  元素

point: 找到 某个下标i  左边第一个大于height[i] 和 右边 第一个大于height[i]的元素下标

mid = st.top(); ->pop();

出栈后  st.top() 为左边第一个

height[i]  为右边第一个；



### **主柱状图种最大的矩形**

反向： 找左右2边第一个小于的元素left right（保证了在left ,right 中间没有比h小的柱子 可以保证 h 可以被容纳）；

强制计算 :  数组前 and 后都加上一个0 ；

不用取min 因为算完一个会继续往左边算  

### 3.1移除k个数字

### 3.2 132模式

单调栈实际上是维护了一个 中间大小的值，

从后往前遍历， 维护一个单调递减栈， 取一个r 值（第二小的值） r 为pop出来的值当中最大的

所以只要此时num[i] < r 即可返回true

### 3.3 2个数组合并出k-size 的最大数

- 前置：

  c++ vector比较  相当于比较每一位的字典序大小

- 方法（分而治之）

  1. 分：nums1 找到 k1-size 的最大序， nums2 找k2

  2. merge ： 每次比较vector A B ， 取大的的那个， 然后将队首加在ans.back上

     （不只是比队首的原因是： 出现情况像此时A 已经只剩1个元素 【0】， B还有很多， 且此时队首相等， 此时就有可能先pop了A， 但是B没pop，那么就不是最大了）

     【此时应该  出B并且B一直出 最后再 + A的【0】】

  3. 比较

     遍历每种情况并且比较找到最大值

# 2  List

重新排布链表时注意要把最后的节点 -> next = NULL 

![image-20220630151211692](C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220630151211692.png)



## 环

- 判断是否有环 以及环的位置

  **注意防止的答案变成环**：如在t[二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)题目中记得  left节点的归NULL，

  ​												  [分割链表（类快排）](https://leetcode-cn.com/problems/partition-list/)的   最终节点-->next 归NULL

## 	1.反转链表

三指针方法： initiate:  

```c++
listnode *next=head->next,*cur=head,*pre=NULL;
```

只需要转换一下cur->next = pre 即可 后续就是数值的传递

用while循环

## 1.1 进阶版 反转任意一段链表

```c++
listnode* reverse(ListNode* head,ListNode* tail);

```



## 	2.复杂链表的复制

unordered_map<node,node> new 先新建一堆地址，并把old node 的val复制进新node

实现next 于random点的复制：

```c++
	cur=head;
        while(cur){
            m[cur]->next=m[cur->next];
            m[cur]->random=m[cur->random];
            cur=cur->next;
        }
	return m[head];
```

## 3.删除节点

删除目前的节点（非first or last ndoe）

```c++
void deleteNode(ListNode* node) {
        node  -> val = node -> next -> val;
        node ->next = node ->next -> next;
    }
//难点在于无法获取前一个节点。
```

将下一个节点变成自己， 干掉自己即可；

## 四个技巧

* 虚拟头 

  给每一个node都设置一个前置node，防止在比如删除head 或者 head为空时插死你哼的特殊处理

* 快慢指针

  判断是否有环

  求两个链表的焦点

  用法：

  2个指针 一个大步走（走2步） 一个小步走（走一步）

  应用：

  ![image-20220328210925169](C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220328210925169.png)

  设置快慢指针 在第一个交汇点x处 slow point重新从start point 走，fast point 继续走 at  speed of 1;   因为 L=D;所以相会在entry point

  ```python
  class Solution:
      def detectCycle(self, head: ListNode) -> ListNode:
          slow = fast = head
          x = None
  
          while fast and fast.next:
              fast = fast.next.next
              slow = slow.next
              if fast == slow:
                  x = fast
                  break
          if not x:
              return None
          slow = head
          while slow != x:
              slow = slow.next
              x = x.next
          return slow
  ```

* 穿针引线

  

#  3 String

字符串中是否有重复字符

1.判断是否非空 返回1

2.如果是仅限制再26小写字母内  特殊判断：size大于26直接返回1；

3.如果仅仅限制在askii内                                 size大于128直接返回

（或者更精确96 因为可以读出的字符字数就是108  从32 的 ‘ ’ 开始）

4.如果限制在Unicode中，（没有输入限制）排序后返回。

## 	3.1.替换空格

双指针：

<img src="https://camo.githubusercontent.com/ceeb030f60d3cea82997354907abfbf403f7ad2caa29fdcda85a3633185076f1/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f65366339643234656c7931676f36716d6576686770673230647530396d3471702e676966" alt="替换空格" style="zoom: 67%;" />

从后向前填充为O(N)

从前向后填充为O（N^2) 因为填充同时还得向后移动



## 	3.2.左旋字符串

reverse()

法2：

substr()

## 3.3.KMP算法

piont:  prefix and appendix of substring 

1. 匹配问题：[28. 实现 strStr()](https://programmercarl.com/0028.实现strStr.html)
2. 重复子串问题：[459.重复的子字符串](https://programmercarl.com/0459.重复的子字符串.html)

下code column 为strstr()的

```c++
int strStr(string haystack, string needle) {
        if(needle.size()==0)return 0;
        vector<int> next = init(needle);
        int l = 0 , s =0,hsize = haystack.size(),nsize = needle.size();
    
    
        while(s<haystack.size()){
            while(s<hsize&&l<nsize&&haystack[s]==needle[l])l++,s++;
            if(l==nsize)return s-l;
            else{
                if(s>=hsize)break;
                while(l&&haystack[s]!=needle[l]) l = next[l-1];
                if(!l)
                while(s<hsize&&haystack[s]!=needle[l])s++;
            }
        }
        
    
        return -1;
    }
vector<int> init(string s){
    vector<int> next(s.size());
    int i=0,j=0;
    for(j=1;j<s.size();j++){
        while(s[i]!=s[j])if(i)i = next[i-1];
                        else {i=-1;break;}
     	next[j] = ++i;
    }
    return next;
}


class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```



# 4 Binary search

二分模板

```c++
可以看成 ：用l为主体则为往右边缩小  用r为往左边缩小
找到满足check条件里第一个满足的元素下标
如果找右边界就用 l = mid
    左边界     r = m
//注意要防止二分查找目标数组中 全体“不符合条件” 或 “全体符合条件” 的特殊情况，并加以特判
int l=0,r=nums.size()-1;
while(l<r){
    int mid=l+r>>1;
    if(check(mid))r=mid;
    //得出的r为第一个满足该check条件的元素位置 如<=target 则为全等于target区间的右边界  
    else l=mid+1;
}

//model 1; find the nearest item fit to the check() function  最边界的元素
//如>= 则找到满足的左边界    <=  则找到有边界
while(l<r){
    int mid=l+r+1>>1;//  if risk overflowing change into: mid=1ll+l+r>>1;
    if(check(mid))l=mid;
    else r=mid-1;
}

//高精度double 型参数
bool check(double val)...//题目要求得某些判别式
void binary(double l,double r){
    double eps=1e-6;
    while(r-l>=eps){
         double mid=l+(r-l)/2;
        if(chenck(mid))r=mid;
        else l = mid;
    }
    return l;
}

```



## 	1.重复的数字

unordered_map<int,bool> st;

## 	2.有序数组查找数字出现次数

**binary search**

## 	3.0-----n中缺失的数字

**binary** **search**

# 5.search(m)

## 	5.1.第一个只出现一次的字符

unordered_mao<int,int> frequncy 遍历一次之后，再遍历找到第一个frequency[i]==1的return i;

## 	5.2.旋转数组中最小的数字

遍历  找到不是递增的第一个数字下表i 后

判断是否跳出循环时 if i是last  return numbers[0]**第一个数字**

​										else return numbers[i+1];

------

闫氏二分做法（OlogN）   面试必做

①找出两端  ： 找出区分的性质------二分的最根本就是区分两段

区分性质：是否大于nums[0];(第一段满足  但  第二段不满足)

```c++
//二分本质 分成两段
//跳出循环的本质  找到最靠近==号的  且满足判断条件的位置
//即 >= 时  找到的r是在等于target的左边界
//   <=时   找到的是有边界
/******************************************************************************/
//此题中因为有重复元素  即前半段和后半段均会有  与nums[0]相同的元素出现的情况 所以不能直接二分
//需要先将尾部与nums[0]相同的元素删除后才能开始
int minArray(vector<int>& numbers) {
        int l=0,r = numbers.size()-1;
        while(l<r&&numbers[r]==numbers[0])r--;
        if(numbers[l]<=numbers[r])return numbers[0];
        while(l<r){
            int mid = l+r>>1;
            if(numbers[mid]<numbers[0])r=mid;
            else l =mid+1;
        }
        return numbers[l];
    }
```



## 	5.3.二维有序数组的查找

看作**bst二分查找树**

用bst的查找来差 **O（logN）**

比val大就往左 i++ 小就往右 j++

## 5.4.quicksort & quickselect

①quicksort

* 方法一

  ```c++
  void qs(vector<int> & nums, int l , int r){
      if(l >= r)return ;//注意终止条件  每次写递归都要检查是否有终止条件
      int i = l -1, j = r+1, x = nums[l];
      while( i < j){
          do i++ ;while(nums[i] < x);
          do j-- ;while(x < nums[j]);
          if(i < j)swap(nums[i],nums[j]);
      }
       qs(nums,l,j);
      qs(nums,l+1,r);
      //分界点在j上 就是说[l,j]里的数字 都小于[j+1,r]里的数字
  }
  ```

* 方法二

  ```c++
  void qs(vector<int> & nums, int l , int r){
  	if(l >= r)return;
      int i = l, j = r , x = nums[i];
  	while(i < j){
          while(i < j && nums[j] >= x) j--;
          while(i < j && nums[i] <= x)i++;
          swap(nums[i],nums[j]);
      }
      swap(nums[i],nums[l]);
      qs(nums,l,i-1);
      qs(nums,i+1,r);
     
  }
  ```


②quickselect

- 方法一

  只能select到一个区间的集合 which 满足条件

  利用quicksort 里的第一个方法

  （时间复杂度和空间复杂度 都好很多）  优先使用

  ```c++
  //分界点为 [l,j],[j+1,r];
  if(j+1 < k) qs(j+1, r, ...);
  else if (j + 1 > k) qs(l ,j, ...);
  return vector<int> (nums.begin(), numsbegin() + k);
  ```

  

- 方法二 

  可以找到准确的第k大的数字 

  利用quicksort 里的第二个方法

  ```c++
  //分界点 [l,i-1] nums[i], [i+1, r];
  ```


## 5.5.有限状态排序

①计数排序

②单指针排序

## 5.6双向BFS

建立2个队列，分别进行bfs扩展

建立2个hashmap distl和distr 记录当前字符串的距离

循环的条件是2队列均非空， 否则说明根本找不到

遍历结束的条件是 当distl 里有 cur_rstring 或者 distr 里有cur_lstring;



# 7.树

## 7.1定义

### 7.1.1完全二叉树

编号从1-n  树的位置从左到右 从上到下排列 

![image-20220330145351013](C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220330145351013.png)

除了应用在完全二叉树本身，其在很多其他计算二叉树 宽度 深度等仿麦呢都有应用  需要自己想象填充NULlptr

**通过pair<TreeNode*,int> 类型的queue 保存数据 进行BFS即可**

### 7.1.2 平衡二叉树

**Balanced Binary Search Tree**

本质BST 且左右差值<=1;

当且仅当两个子树的高度差不超过1时，这个树是平衡二叉树。（同时是排序二叉树）



## 7.2 7个技巧

递归的写法

- 确定返回值 以及 参数

- 确认终止条件

- 确定单层逻辑

  ① 遍历一条边 

  ```
  if(recur) return ;
  if(recur) return;
  ```

  ②遍历整棵树

  ```c++
  treenode * left = recur(node->left,....);
  ...right ......
  ```

  

### 重头戏 递归改迭代

统一写法：

1. 中序遍历

   带标记的写法

   ```c++
   vector<int> inorderTraversal(TreeNode *root){
       vector<int> ans;
       stack<TreeNode*> s;
       if(!root)s.emplace(root);
       while(!s.empty()){
           Treenode *node = s.top();
           s.pop();
           if(node){
               //添加右中左节点进入stack 保证顺序
               if(node -> right) s.emplace(node -> right);
               s.emplace(node);
               s.emplace(NULL);
   
               if(node->left) s.emplace(node->left);
           }
           else{
               //若为空节点 则重新取出
               node = top();
               s.pop();
               ans.emplace_back(node->val);
               //只有当空节点时才说明该节点顺序正确  
               //能进行遍历处理 否则还在寻找节点阶段
           }
           return ans;
       }
   }
   ```
   
   
   
2. 先序遍历

   将顺序改成右左中即可

   或者建议用本来的模板

3. 后序遍历

   将顺序改成 中右左即可
   
4. 对称二叉树的写法

   此时不是经典的前中后序遍历  但是也能用stack or queue来模拟
   
   关键在要按比较顺序push进stack or queue
   
   ```c++
   //push 过程
   while(q.size()){
       treenode *a = q.front();q.pop();
       treenode *b = q.fron();q.pop();
       if(a && !b || !a && b||a->val != b->val)return 0;
       if(!a && !b)continue;
       q.emplace(a->left);
       q.empalce(b->right);
       q.emplace(a->right);
       q.emplace(b->left);
   }
   ```
   
   

### else

* 双递归

  基本应用题目中不会有更多层的递归（dfs）

  关键词  **任意节点开始**

* 前后遍历

  更多题目依赖于后序遍历  即 from bottom up类型 依赖左右子树的返回值

  ```c++
  dfs(){
  	dfs(node->left);
  	dfs(node->right);
      .....//先遍历在进行处理数据
  }
  ```

  有依赖于谦虚遍历的 [从跟到叶的二进制数之和](https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/)

* 虚拟节点  

  ```javascript
  var pruneTree = function (root) {
    function dfs(root) {
      // do something
    }
    ans = new TreeNode(-1);
    ans.left = root;
    dfs(ans);
    return ans.left;
  };
  ```

  

* 递归改迭代

  ①普通二叉树 
  
  - 先续遍历  
  
    用stack'模拟
  
    ```c++
    s.emplace(root);
    while(s.size()){
        treenode * node = s.top();
        s.pop();
        ......//对改点的处理
        if(node->left) s.emplace(node->left);
        if(node->right) s.empalce(node->right);
    }
    ```
  
    
  
  - 后续遍历
  
    ```
    
    ```
  
  - 中序遍历
  
    ```c++
     vector<int> inorderTraversal(TreeNode* root) {
            stack<TreeNode*> s;
            vector<int>ans;
            if(!root)return {};
            TreeNode* node = root;
            while(node || s.size()){
                while(node && node->left){
                    s.emplace(node);
                    node = node->left;
                }
                if(!node){
                    node = s.top();
                    s.pop();
                }
                ans.push_back(node->val);
                node = node->right;
            }
            return ans;
        }
    //another version
    	while(node || s.size()){
            if(node){
                s.emplace(node);
                node = node -> left;//左
            }
            else{
                node = s.top();
                s.pop();
                ans.push_back(node->val);//中
                node = node -> right;//右
            }
        }
    ```
  
  ②二叉搜索树
  
  - 先序遍历
  
    因为有BST的性质 无需使用stack来模拟  //如果有值的话
  
    ```c++
    while(root){
    	if(root->val > target){
            root = root -> left;
        }
        else if(root -> val < target){
            root = root ->right;
        }
        else return root;
    }
    ```
  
  
  
  
  

## 7.3应用

三种题型

构造类  搜索类   修改类 其中修改类比较难

树的建立

一般都是2个遍历结果为依据进行遍历， 如果遇到像BST 只用一个遍历结果就行（因为已经隐含了一个inorder traversal）

树的序列化建立：

(data数组 -> treenode)

利用3指针  p1 moves 1, p2 moves 2 p3 moves 2 each time;   +BFS

每次 bfs时  不放入NULL   取 p1为queue.front(),  i+=2;(p2=i,p3=i+1);

数的最大宽度：

使用hash<treenode*,int> to store data;  however to modify the space complexity:

**通过pair<TreeNode*,int> 类型的queue 保存数据 进行BFS即可 **

**注意溢出问题：根据每层的leftmost,   在更新节点的下标时  都要用(pos-leftmost)处理**

如： 

```c++
if(node->left)q.push({node->left,(posmost-leftmost)*2});
if(node->right)q.push({node->right,(posmost-leftmost)*2+1});
```



## 7.3.1修改类

* 删除

  **后序遍历 + 虚拟节点**

  碰到增槎删改时  通常要想到虚拟头的方式 来储存地址

  删除BST 中一个节点

  ```c++
  // left right 后继节点 中一个为pre
  //如果both =NULL 直接删除node （node必须为引用变量 否则无法删除）
  //如果存在一个  如在left里，进行替换后 delete(node->left,pre->val);
  
  ```

  ```c++
  //如果cur 的右节点为空 返回左节点 
  //先找到右节点中 最小的一个，（最靠左下的一个） 把cur 的左节点放到最小节点的左子树里，返回cur -> right即可
  ```

  

* 算法需要自己修改

  如[863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/) 通过修改树的节点类，增加一个指向父节点的map_parent  而后从node BFS 就行



## 找到最近的公共祖先

1.BST版

先将二者按大小排序

递归三种情况

① q->val < root->val  往root—>left递归

②p->val > root->val  往 root->right 递归

③ return root;  



## 双向链表与BST

```c++
    Node *head,*pre=NULL;
    Node* treeToDoublyList(Node* root) {
        if(!root)return NULL;
        inorder(root);
        pre->right=head;
        head->left=pre;
        return head;
    }
    void inorder (Node* root){
        if(!root)return ;
        inorder(root->left);
        if(pre==nullptr)
            {head=root;}
        else pre->right=root;
        root->left=pre; 	//root 和 pre的操作不能转换顺序 否则将会pre -> right = pre; 报错
        
        pre=root;
        inorder(root->right);
    }
```



##   BFS打印树

### 	1.每层分开打  层间有换行

用到queue::size()函数与for循环遍历   再while循环中

```c++
while(!q.empty()){
    int size=q.size();
    vector<int> temp;
    for(;size--;q.pop()){
		treenode *now=q.front();
        if(now->left)q.push(now->left);
        if(now->right)q.push(now->right);
        temp.push_back(now->val);
    }
    ans.pushback(temp);
}
```

##   Substructure of the tree



### 	1.树的子结构

递归解决 

```c++
bool dfs(treenode* a,treenode* b){
    if(!b)return true;//出口1  b已经一部分校对完了
    if(!a)return false;//出口2 b还有有效点  但是a==NULL则
    if(a->val==b->val)return dfs(a->left,b->left)&&dfs(a->right,b->right);
    else return false;
}
bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(!B||!A)return false;
        return dfs(A,B)||isSubStructure(A->left,B)||isSubStructure(A->right,B);//母函数也需要递归
    }
```

dfs（）

1.recur停止条件

* a或b节点为nulptr NULL   b为子 出则true  a为母 出则false
* 若二者值不等 return false;

2.层间关系是

* 该层两点值相同 并判断该点的子树（下一层（左右节点））是否完全一致



母函数 issubstructure（）：

1.recur停止 

* dfs返回值为1 -> true
* A B 均为NULL ->找到尽头 ->false

2.层间关系

* 如果dfs返回false  则继续找A的子结构（左右子树）与B的关系



### 2.judgements on symmetry

1.递归停止的条件是什么？

- 左节点和右节点都为空 -> 倒底了都长得一样 ->true
- 左节点为空的时候右节点不为空，或反之 -> 长得不一样-> false
- 左右节点值不相等 -> 长得不一样 -> false

2.从某层到下一层的关系是什么？

- 要想两棵树镜像，那么一棵树左边的左边要和二棵树右边的右边镜像，一棵树左边的右边要和二棵树右边的左边镜像
- 调用递归函数传入左左和右右
- 调用递归函数传入左右和右左
- 只有左左和右右镜像且左右和右左镜像的时候，我们才能说这两棵树是镜像的

3.调用递归函数，我们想知道它的左右孩子是否镜像，传入的值是root的左孩子和右孩子。这之前记得判个root==null。

```c++
bool check(TreeNode* a,TreeNode* b){
        if(!a&&b)return false;
        if(!b&&a)return false;
        if(!b&&!a)return true;
        return a->val==b->val&&check(a->left,b->right)&&check(a->right,b->left);
    }
    bool isSymmetric(TreeNode* root) {
        if(!root)return true;
        return check(root->left,root->right);
    }
```

#  8 动态规划DP

**做题思考模式**

从集合的角度思考

* ①状态标识： dp【i】【j】 存储的是什么信息（比如青蛙是dp【i】存储到第i台阶的步数）

* ②dp属性： 找到MAX值 /MIN值 / 数量

* ③转移：（每一层的来源 ，如何到达的f【i】【j】）

  ​					（于摘花生 中 为①最后一步从上面下来   ②从左边过来）

  ​						（若要计算2条路线时  ①左左 ② 上上③左上④上左）

* ④计算 根据②属性 （max，min，sum）

  ​	**①注意第一行第一列处理**

  ​	**②注意格子边界问题  如坐标在【0，n-1】中**

* **做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

* 然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

##  1.斐波那契数列

主要是体现dp的存储作用 来满足减小时间复杂度的需求

①数组存储  同时可用于打表

②临时三个数字 abc min 时间空间复杂度



## 2.青蛙跳台阶问题

非常经典的问题  在后续很多题目都有类似的题目出现，主要是学会抽象出来并类比

## 3.色子问题

输入n 找出扔n个色子时，每种结果和的概率。

状态标识： f(n,x)  == 扔n个色子时，总和为x的概率

![image-20220310200819977](C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220310200819977.png)



```c++

```



## 4.跳跃问题

给一个vector<int> nums 意味着每个元素所能移动的最大距离  问是否能到达终点  

定义一个maxpos 为目前能到达的最大右边界

   需要再定义一个end 为判定是否可以触碰到；功能： 每当遍历到end时就更新end 为maxpos   **实际模拟的是跳跃过程**

 return  end>=nums最大边界



**跳跃问题2** 实际就是把跳跃1种的更新过程加一个 ans++的操作

```c++
//注意遍历的终点为nums.size()-2因为此时已经能到达最终的nums.size()-1了
//因为题目已经保证了我们可以到达最终边界   所以最后一步不用更新跳跃（ans）即不用遍历
for(int i=0;i<nums.size()-1;i++){
            maxpos=max(maxpos,nums[i]+i);
            if(end==i){
                end=maxpos;
                ans++;
            }

        }
```

## 5.剪绳子

有一段长为n 的绳子  需要得到剪断后每段的长度的乘积 最大 

①dp做法

令f[n]表示最大的乘积

传递：

f[n]=f[n-i]*f[i]

遍历的区间为1-n/2; 

```c++
 for(int i=4;i<=n;i++){
            maxn=0;
        for(int j=1;j<=i/2;j++){
            maxn=max(maxn,dp[j]*dp[i-j]);
        }//bi
        dp[i]=maxn;
        }
```





## 	1.数学三角形模型

* ### 摘花生问题

  思路：

  ①状态标识：f【i】【j】：存储当前能摘到得最多花生数量

  ②属性：MAX

  ③转移：左边 / 上面

  计算：（根据属性及转移）：

```c++
//attention： 遍历从i,j=1开始  till n；
f[i][j]=max(f[i-1][j],f[i][j-1])+g[i-1][j-1];// so i-1 j-1;
```

* ### 最低通行费

  ① 状态标识： f【i】【j】

  ② 属性： MIN（）

  ③ 转移： 左边/上面

  计算：

  ```c++
  //attention: 第一行第一列时 因为min函数会优先取val==0的值 (f[1-1][j]//f[i][j-1]均为初始值；)
  //so 特殊处理： if(i==1) f[i][j]=f[i][j-1]+g[i-1][j-1];
  //   		  if(j==1)f[i][j]=f[i-1][j]+g[i-1][j-1];
  f[i][j]=min(f[i-1][j],f[i][j-1])+g[i-1][j-1];
  
  ```

* ### 方格取数

2行并走  同时搜索

①状态标识： f【k】【i1】【i2】  //k表示横纵坐标之和，i1表示第一次横坐标，i2表示第二次

② 属性： MAX（）

③转移：4个来源    i1/i2 * 左边/上面

计算

```c++
int k=2;
    for(;k<=n+n;k++)
    for(int i1=1;i1<=n;i1++)
    for(int i2=1;i2<=n;i2++){
        if(k-i1<=0||k-i2<-0||k-i1>n||k-i2>n)continue;//边界处理
        int t=g[i1][k-i1];
        if(i1!=i2)t+=g[i2][k-i2];
        int &temp=f[k][i1][i2];
        temp=max(temp,f[k-1][i1-1][i2-1]+t);//
        temp=max(temp,f[k-1][i1][i2-1]+t);
        temp=max(temp,f[k-1][i1-1][i2]+t);
        temp=max(temp,f[k-1][i1][i2]+t);
    }
```

## 2.背包问题

* ### 2.1 0/1背包

①状态标识： f【i】【j】i： 表示前i个物品中选择   j： 总共可用背包容量

②属性： MAX

③转移：  ①如果j<v[i]则直接继承f【i-1】【j】

​				②比较不包含w【i】得f【i-1】【j】   ||   以及包含了w【i】却得减小体积搜索上层  f【i-1】【j-v【i】】+w【i】

计算：普通算法  （朴素） 时间复杂度O（N^2) 

```c++
for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
	for(int i=1;i<=n;i++)
	for(int j=1;j<=r;j++){
		if(j<v[i])f[i][j]=f[i-1][j];
		else{
			f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);
		}
	}cout<<f[n][r];// 时间复杂度O（N^2) 
//简单优化 最终解法
//利用滚动数组来做  因为只跟上一层产生了关系  [i] and [i-1];
/**********************************************************************************/
	for(int i=1;i<=n;i++)
	for(int j=r;j>=v[i];j--)//① 逆序是因为更新早晚的问题  如果从小的开始更新，则后续f【j-v【i】】会出问题，变成已经更新过的版本  
         //②大于v【i】是优化时间复杂度
			f[j]=max(f[j],f[j-v[i]]+w[i]);
            cout<<f[r];
```

​	

​	

* ### 2.2 完全背包问题

区别在于物体可以重复选择

朴素写法

```c++
f[i][j]=max(f[i-1][j-k*w[i]]+k*v[i]);//遍历k个可行方案  三重循环

//优化①
f[i][j]=max(f[i-1][j],f[i][j-w[i]] + v[i]);//只用跟同一层的对比减少了一层循环
                         
//优化②
for(int i=1;i<=n;i++)
for(int j=v[i];j<=m;j++){
    f[j]=max(f[j],f[j-w[i]] + v[i]);//因为此时比较的不是同一层（一个是i层另一个是i-1  层所以可以从小到达遍历
}
```

<img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220301211214481.png" alt="image-20220301211214481" style="zoom: 50%;" />

* ### 2.3 多重背包问题

  与完全的区别在于会输入可以选取的数量。所以在遍历上回多一层

  ```c++
  // 朴素版本   O(N * V * S)
  //在完全背包问题上多家一层的循环 for (...k<=s[i]&&k*v[i]<=j...)
  // s[i] 为该层的可选取的物品数量
  
  /*************************************************************************************/
  //优化版本  二进制  O（N V log S）
  /*
  	将s（可选量）遍历优化为O（logN）
  	200 = 2^7-1(等比求和) +73;  遍历n=8次  0-6（64）+1  （cuz 128用不上，太大了）
  	1023=2^10-1 （等比求和）  遍历 10次 0-9
  	而换成代码语言就是：
  	把单个可选量s-> 对应遍历次数n 的元素储存对应2的n阶乘*体积/价值 -> 存储->全部看作单独的个体
  	->进行 0/1背包问题最优化解决
  */
  int cnt=0;//存储的下标
  for(int i=;i<=n;i++){
      int a,b,s;//体积 价值 可选量
      cin>>a>>b>>s;
    	int k=1;
      while(k<s){
          cnt++;
          v[cnt]=a*k;
          w[cnt]=b*k;
          s=s-k;//important
          k=k*2;
      }   
      if(s>0){//还剩下多少没保存
          cnt++;
          v[cnt]=s*a;
          w[cnt]=b*s;  
      }
  }//储存完毕   O(N*log s)
  //接下来进行0/1背包问题处理   n'=cnt  m'=m ; O(m'*n')=O(m*n*logs);
  
  
  ```

* ### 2.4 分组背包问题

  区别在于每次只能从一组中选一个

  思路：

  ①状态储存：f【j】 //   最大容量为j

  ②属性 ： MAX  

  ③来源 ①继承 f【j】不包含   ；② 包含该i组 第k个   **0/1背包问题+ 一层遍历**

  ```c++
  for(int i=1;i<=n;i++)
      for(int j=m;j>=v[i];j--)
          for(int k=0;k<s[i];k++){
              f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);
          }
  return f[m];
  ```

  

## 3.最长上升子序列

* ### 最长上升子序列

①状态标识：f【i】以第i个数字结尾的最长上升子序列长度

②属性：长度的MAX

​					(e.g:    3 1 2 1 8 5 6） f【4】 即以8 结尾的最长上升子序列长度

③转移：  根之前的所有 a【j】 比较是否大于  则a【i】可接在a【j】后面  f【i】=f【j】+1；

​				如果全部没有则f【i】=1；

```c++
if(a[i]>a[j]){
    if(f[j]+1>f[i]){
        f[i]=f[j]+1;
    }
}
```



* ### 最长公共子序列

  问题描述： 既是a字符串的子序列  又是b字符串的子序列  的最长长度是多少

  ①状态标识：f【i】【j】由第一个子序列的前i个字母 和第二个子序列前j个子序列  中包含的最长子序列

  ② 属性MAX 长度

  ③状态计算 

    有2个字母 a[i] b[j] 选/不选  所以一共四种情况。

  00： f【i-1】【j-1】 也被包含在10 01 11的情况下  所以可以忽略

  01：f【i-1】【j】严格包含01的情况。 并不一定包含b【j】

  10：f【i】【j-1】 只是前i跟前j-1个字母所包含的最大子序列  并不一定包含a【i】

  11：f【i-1】【j-1】+1； **该种情况时a【i】==b【j】**

```c++
for(int i=1;i<n;i++)
for(int j=1;j<m;j++)//均从1开始 因为下面有-1 -1 的操作 避免overflow。
{
    f[i][j]=max(f[i-1][j],f[i][j-1]);
    if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1);
}
return f[n][m];
```

​	本体debug：

```C++
  cout<<i<<' '<<j<<' '<<f[i][j]<<endl;
```

## 4.区间DP问题

* ### 合并石子问题

  **只能合并相邻**的2堆石子，将其合并为一堆石子，每次合并耗费力气为2堆石头的总质量，找出最小的耗费体力的方法

  ①状态标识 f【i】【j】 将第i堆石子 导第j堆石子 合并导一堆石子的合并方式  答案f【1】【n】

  ②属性 MIN **注意初始化时1e18**

  ③状态计算  分成k类 以分界线来分类    第k类的表示方式f【i】【k】+f【k+1】【j} + sum

  ​																										前缀和sum=s【j】-s【i-1】

  ```c++
  for(int len = 2;len<=n;len++)//因为len==1时，不用合并总用工为0 可忽略
  for(int i=1;i+len-1<=n;i++){
  	int l = i,r = i+len-1;
      f[i][j]=1e18;//求最小值时的初始化过程
      for(k=l;k<r;k++)//遍历边界  因为有k+1 所以k的右边界只能是<r；
          f[i][j]=min(f[i][j],f[i][k]+f[k+1][r]+s[r]-s[l-1]);//更新
  }
  ```

  

## 5.计数类DP

计数问题：

记录[a,b]间每个数字出现的次数。

思路：

<img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220308202539122.png" alt="image-20220308202539122" style="zoom:50%;" />

修改： **当前导abc均为0是，d不能为0**所以应该从yyy=001-abc-1

```c++
int count(n,x);//1-n中x出现的次数
//前缀和思想 
//如果求[a,b]中x出现的次数 cout(b,x)-count(a,x);
//强调的是分情况讨论。如上图

```

### 剑指43.记录1-n中整数1出现的次数

```c++
//记录：当处理第i位时digit (x),digit(x-1) ..digit(i+1)为high  digit(i-1)--digit(1)为low
//分类讨论： 
//digit(i)==0  count = high*次幂;
//digit(i)==1  count = high*次幂+low+1;
//digit(i)>1   count = (high+1)*次幂;
int appearingtimesof1(int n){
    long long high=n/10,cur=n%10,low=0,digit=1;
    while(high||cur){
        ans+=digit*high;
        if(cur==1)ans+=low+1;
        else if(cur>1)ans+=digit*1;
        low+=cur*digit;
        digit*=10;
        cur=high%10;
        high/=10;
    }
    return ans;
}
```



## 6.状态压缩DP

6.1蒙德里安的梦想

n \*m的棋盘分成若干个1*2的长方形 有多少方案

思路：  （当横向方格放置完成后，只能由一种方法防止竖向）

状态标识f【i】【j】 第i列   j为一个2进制数字标识状态（5bit 0-31  ）：

​			（已经摆了i列，第j行是否突出一个已放置方格  10010为第1行第4行为摆置了方块）

```

```

## 7.状态机

General Concep：

<img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220309135234731.png" alt="image-20220309135234731" style="zoom:67%;" />

简单概念应用：in game:

​	站立 跑 攻击      形成环形图  点跟相邻点之间可以相互转换

与状态压缩相当 为另类表示状态的方式。

当不好只用一个数字表示状态时   ，的一种思路

* ### 大盗阿福 （打家劫舍系列）

  不能打劫相邻的商店，求最大价值。

  思路

  状态表示：f【i】  前i家最大

  来源   ①抢劫第i家店铺 ② 不抢第i家店铺  (但是无法标识 是否抢了第i家店铺)

  故而 加一个j变量 {0，1}； 标识是否选了这家店铺

  **利用”状态机“：**

  变成  ①   f【i】【1】 =  w【i】+f【i-1】【0】

  ​		② f【i】【0】 = max （f【i-1】【0】，f【i-1】【1】）；

* ### 股票买卖IV

  不能同时参与多笔交易（只能0时买入）

  最多进行k笔交易

  状态表示：f【i】【j】【0】i天 进行完毕了j笔交易  0手中无货 1有货

  状态来源：

  ```c++
      memset(f, -0x3f, sizeof f);
  all(f[i][0][0]=0;)//只能从此开始意味着 并不限定于第0天开始
  //遍历从1开始到<=n
  f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]+w[i]);
  f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0]-w[i]);// 每次交易 先从1开始再到0 所以最后一笔交易为 f[n][k][0];
  
  //最后选择一个无货时的最大值  不一定是最后一次
  int res = 0;
  for(int i=0;i<=m;i++)res=max(res,f[n][i][0]);
  return res;
  ```

  

  ```c++
  //滚动数组优化  在准备数组时  可以将其对1取mod  降到只有2层的数组
  f[i%1][j][0]= ....f[(i-1)%1][j][0]......
  
  ```

  

* ### 股票买卖V

  尽可能多的交易。（但也不能同时交易）（卖出之后冷冻一天 无法买入）

  ```c++
  for (int i = 1; i <= n; ++ i)
      {
          f[i][0] = max(f[i - 1][0], f[i - 1][2]);//0 representavailable for buying
          f[i][1] = max(f[i - 1][1], f[i - 1][0] - w[i]);// buy
          f[i][2] = f[i - 1][1] + w[i]; //2 represents just being sold out still in freezing period
      }
  //滚动数组优化 空间复杂度降维  也是将其进行对1的取模
  ```

  ## 8树形dp

  没有上司的舞会

  在不包含直接上司的情况下，高兴度之和最大值

  

  # 

# 9.堆专题

* 中心问题

  动态求极值（both 动态 极值）**动态规划？？也是**、

  四大应用：

  1. topK
  2. 带权最短距离
  3. 因子分解
  4. 堆排序

* 原理分析

  * 跳表（**对于有序表**）

    核心思想 2分

    取代哈希表+单链表 更好的空间复杂度 同时可以解决找极值的问问题

    将每一层的每2个元素抽出来 加一个索引在上一层

    ![image-20220330111407873](C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220330111407873.png)

    在查询时  if 当前节点值> target && node->naxt->val<target

    ​						就跳入下一级

    //如图所示 ,target =10，7<10,18>10  so step into the next level

    ​		if(target == node->val)return node;

    

  * 二叉堆（完全二叉树）

    中序遍历输出的结果 为升序

    且满足堆的定义

    堆基本操作；

    ```c++
    //插入
    heap[++size] = x; up(size);
    //求最小值
    heap[1];
    //删除最小数
    heap[size--] = heap[1];
    down(1);
    //删除任意数
    heap[size--] = h[k];  down(k); up(k);
    //修改任意数
    heap[k] = x; down(k); up(k);
    
    //建堆：
    //先将数组变成大顶堆，再不断往最后一位swap 并从上往下adjust即可
    for(int i = size/2; i>=0;i--){
                down(i);
            }
            while(size>=1){
                swap(heap[0],heap[size-1]);
                size--;
                down(0);
                
            }
            return heap;
    }
    
    void up(int k){
        while(k/2){
           	int i = k/2;
            if(heap[i] > heap[k])
                swap(heap[i], heap[k]);
        }
        k = i;
    }
    void down (int k ){
        int j = k;
        if(k*2 <= size) j = 2 * k;
        if(2 * k + 1 <= size && heap[2*k+1] < heap[2*k]) j = 2*k+1;
        if(heap[j] < heap[k]){
            swap(heap[j], heap[k]);
            down(j)
        }
    }
    ```

    出堆：

    ```c++
    downadjust(low,high): 
    {	while(存在孩子节点 j<=high){
    		存储最大的孩子坐标
    		if（heap[child]>heap[parent]) {swap（）；并将处理点i移至 j ，j=2*i）
    		else break;
    }}
    
    upadjust(low,down){
    	i=high;j=i/2; j为其父亲
    	while(j>=low存在父节点){
    		if(heap[i]>heap[j]){swap(),处理点i移至j，j=i/2;}
    		else break;
    	}
    }
    //先将顶端node删除
    //将最后一个节点换到顶部  往下downadjust
    //参考down adjust
    
    ```

    入堆 

    最后一个节点插入新val  后upadjust

    建堆

    从头到尾downadjust遍历数组

## 9.1技巧

### 9.1.2固定堆

维持k不变 每pop一个出去就push一个进来  **（固定窗口）**







* application

  * 超级丑数 ：给定一个数组 给出第n个大的丑数  whose 公因子只能在数组里

    ①可以用dp

    ②用优先队列

    ​	将数组中国所有数字移进堆里

    ​	动态维护当前最小的超级丑数 

    ​		（将当前堆里的最小数字 n0 与所有堆中数字相乘 --> set 

    ​			 push	set all menbers 进堆     pop n0);

    **存在问题数组中含有含有公因子的2数字时 **

    **用hash 或者 **

    **记录上次pop的数字  与 这次取出的数字比较  是否满足严格递增 **

    ```c++
    int nthSuperUglyNumber(int n,vector<int> prime){
        if(prime.empty())return 0;
        long long count=0,ans=1;//ans =1 1为虚拟头 保证有效
        priority_queue<int,greater<int>,vector<int>> minque;
        for(int i:prime)minque.push(i);
        while(count<n){
            ans = minque.front();
            while(minque.size()&&minque.top()==ans)minque.pop();
            //这步是为了保证出队列的元素步重复  保证单调递增
            coutn++;
            for(int it:prime)minque.emplace(it*ans);
        }return (int)ans;
    }
    ```

    

    

# 10.数学

## 快排变形

**数据的二段性** ： 目标： 将数组的所有item 按照一个原则分为2组

那么此时就能利用快排来进行 分组 分成2 个组

如 剑指offer 将奇数排于偶数前面

## 10.1 圆圈种的最后剩下数字

f[n,m]表示，n个数字一共（from 0 to n-1），去掉序列为m的数字  时  此时的该去掉的数字下标

f[n,m]=0 (n==1)

​			=(f[n-1,m]+m)%n  (n>1)  //因为相加之和有可能超越了数字上界。所以取%

```c++
  ans=(m+ans)%i;//i为目前的容量 ans为上次的开始数的数字下标
                              //   第一次因为只剩一个数字 所以ans=0
        
```

```c++
//analog version
int lastRemaining(int n,int m){
    vector<int> list;
    int now=0;
    for(int i=0;i<n;i+=)list.emplace_back(i);
    while(list.size()){
        now=(now+m-1)%list.size();
        list.erase(list.begin()+now);
    }
    return list[0];
}

```

## 概率论

- rand7 -> rand 10

  基于 （rand7 - 1） * 7  +rand7 在【1， 49】等概率

  后续优化：

  可将每10个看成一组 所以 %10  而第一轮只能去掉9个无效数字【41 - 49】 比较少

  继续往下直到省去1个数字才最佳。

  ```c++
  int rand10() {
          int num;
          while(1){
              num = (rand7() - 1) * 7 + rand7();
              if(num <= 40)return num % 10 + 1;
              num = (num - 40 - 1) * 7 + rand7();
              if(num <= 60)return num % 10 + 1;
              num = (num - 60 - 1) * 7 + rand7();
              if(num <= 20)return num % 10 + 1;
          }
          return num % 10 + 1;
      }
  ```

- rand10 -> rand 7

  也是 如果num > 7 省略 <= 7 就return就行

## 计算质数

```c++
class Solution {
public:
    int countPrimes(int n) {
        vector<bool> isprime(n,1);
        for(int i = 2; i < n; i++){
            if(isprime[i]){
                for(int j = i + i; j < n; j+=i){
                    isprime[j] = 0;
                }
            }
        }
        int ans = 0;
        for(int i = 2; i < n; i++)
            if(isprime[i])ans++;
        return ans;
    }
};
```

相当于踩坑游戏。

将每个（质数）都当作一个跳跃的步伐，跳到终点位置，每个坑都标记上，意味着这个点有（非1）的约数。

# 11.滑动窗口

常见题型：连续字串 、连续子数组

不同类型：固定窗口，可变窗口（MAX，MIN）

> 初始化慢指针 = 0
> 初始化 ans
>
> for 快指针 in 可迭代集合
> 更新窗口内信息
> while 窗口内不符合题意
>    扩展或者收缩窗口
>    慢指针移动
> 更新答案
> 返回 ans

[长度最小子数组；](https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/209-chang-du-zui-xiao-de-zi-shu-zu-hua-dong-chua-2/)

```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        l = total = 0
        ans = len(nums) + 1
        for r in range(len(nums)):
            total += nums[r]
            while total >= s:
                ans = min(ans, r - l + 1)
                total -= nums[l]
                l += 1
        return  0 if ans == len(nums) + 1 else ans
```

## 11.1双指针

1.三数之和

注意判定是否重复 

```c++
if(i&&nunms[i]==nums[i-1])continue；//nums[i]==nums[i+1]会忽略掉一些情况
    
  .....;
//after 赋值  去重操作
ans.push_back(...);
while(l<r&&nums[r]==nums[r-1])r--;
while(l<r&&nums[l]==nums[l+1])l++;
l++,r--;
```

2.盛水最多的容器

指出：双指针的作用 就是去掉 不可能是最大值的一项

​			如果向内移动较大的那根   则 结果一定变小

​			如果向内移动较小的那根   则 结果有可能变大

# 12.回溯

## 可能存在的优化

- 状态数组代替

  如果什么优化都做完了，但是还没办法过完所有的案例， 那么就尝试将所有的返回值保存在一个状态数组里， （利用输入参数进行标记） 

  如果已经遍历过这个情况， 那么就直接return， （相当于一次剪枝）

  E.g: [交错字符串](https://leetcode.cn/problems/interleaving-string/)

## 去重问题

①不用按顺序

​	那么sort + st使用记录 即可



②需要按顺序 （如上升子序列 问题） 

则在每一层添加一个unordered_set 来进行记录 这一层 只能用一次这个数字

- 优化  如果数字有范围 则可以将set 变成一个数组（计数的数组 如范围为-100 -100 则开一个201的大小数组）



```c++
bool st[201] = {0};
if(st[nums[i] + 100])continue;
```

③组合问题去重 [2 2 3] [3 2 2] 去重

```c++
void dfs(int n,int idx){
        if(n == 0){
            ans.emplace_back(buffer);
            return;
        }
        for(int i = idx; i < num.size() && n >= num[i]; i++){
            buffer.emplace_back(num[i]);
            dfs(n - num[i],i);
            buffer.pop_back();
        }
    }
```

直接递归参数中传递进开始下标  即可按照顺序来输出结果

## 经典案例

见到组合 /排列 /有效输出 等字眼时的常见提题型

①全排列

```c++
//先排序 作用： 将有效的且相等的item排在一起
sort(num.begin(),nums.end());
//建立查询visited
vector<bool> st(nums.size());
//避免重复选择
for(itn i=0;i<nums.size();i++){
    if(i&&nums[i]==nums[i-1]&&!st[i-1])continue;//跳过相同字符中 前面没选 选则后面的情况。
}
/*---------------------------------------------------- */
//交换法全排列
class Solution {
public:
    void dfs(vector<string>& res, string& S, int i)
    {
        if (i == S.length()-1)//因为最后一个不换也行， 自己跟自己换是一样的
        {
            res.push_back(S);
            return;
        }
        
            //注意 j 的下标从 i 开始，因为原排列也是一种排列
            for (int j = i; j < S.length(); ++ j)
            {   //从i 开始， 那么就意味着可以不动
                swap(S[i], S[j]);       //交换字母
                dfs(res, S, i + 1);
                swap(S[i], S[j]);       //还原
            }
        
    }

    vector<string> permutation(string S) {
        vector<string> res;

        dfs(res, S, 0);

        return res;
    }
};
//去重
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        dfs(0, nums);
        return ans;
    }
    vector<vector<int>> ans;
    void dfs(int idx, vector<int> &nums){
        if(nums.size() - 1 == idx){
            ans.emplace_back(nums);
            return ;
        }
        unordered_set<int> st;
        for(int i = idx; i < nums.size(); i ++){
            if(st.count(nums[i]))continue;
            st.insert(nums[i]);
            swap(nums[idx],nums[i]);
            dfs(idx + 1, nums);
            swap(nums[idx], nums[i]);
        }
    }
};

```

②子集

```c++
//记得在ans里加空集在先
ans.emplace_back({});
//有重复元素
sort(nums.begin(),nums.end());
void dfs(int cur....){
    //如果有重复字符  
     if(cur&&nums[cur]==nums[cur-1]&&!st[cur-1])continue;
    for(int i=cur;i<nums.size();i++).....//避免与前面字符重复，而选择的剪枝
}// 如果没有重复字符的话这样已经足够

```

③分割回文串

先预处理 就不用一个一个处理了

```c++
 for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = (s[i] == s[j]) && f[i + 1][j - 1];
            }
        }

```

③斐波那契式序列

```c++
class Solution {
public:
    vector<int> splitIntoFibonacci(string S) {
        vector<int> res;
        backTrack(res,S ,0,0,0);
        return res;
    }

    bool backTrack(vector<int>& res, string S, long long sum, int idx , int prev){
        //当遍历完成
        if( idx == S.size()){
            结果数组长度大于3，则返回True
            return res.size() >= 3 ;
        }
        long long cur = 0;
        //切分数字
        for (int i = idx ;i < S.size() ; i++){
            //当前切分数大于最大整型INT_MAX，进行剪枝
            if ( i>idx && S[idx] == '0'){
                break;
            }
            //计算所切分数的数值大小
            cur = cur*10 + S[i] - '0';
            //当前数大于前两数之和，可行性剪枝  special for C++ 11
            if ( cur > INT_MAX)
                break;
            //当结果数组长度大于等于2时，
            if(res.size() >=2 ){
                //若当前的切分数小于前两数之和，则继续添加下一位
                if(cur < sum) continue;
                //若切分数大于前两数之和，剪枝  可行性剪枝
                else if(cur> sum) break;
                
            }
            //backtrack
            res.emplace_back(cur);
            if(backTrack(res,S,prev + cur,i+1,cur)) return true;
            res.pop_back();
                
            
            
        }
        return false;
    }
};

```

3.解数独

状压 + 回溯

- 状压 

  此刻可以用的数字 为 row[x] & col[y] & cell(x/3, y/3);

- 初始化状态压缩映射

   **注意此时的 状态 '1' 对应'000000001' 即 1 << 0 所以在后续处理上我们在字符上 + - '1'  instead of '0'**

  map为lowbit对应的单字符映射  大小为 [1 << 9] 但是用到的只有9 个

  ones 为当前状态对应的可执行方案数量  大小为 [1 << 9];

- 初始化row col cell 

  全部初始化为 1 <<9 -1;

- 记录cnt 

- dfs  

  类型为 bool  如果找到了方案 则 return 1 

  在每次递归时都if (dfs(///...)) return 1;即可提前跳出循环

  方案：

  每次都先找到对应可行方案数最小的点 然后从该点开始行动 画图 递归 回溯  done！
  
  

4.将数组均分为k组

- 整体思路

  新开一个bucket数组，负责放置数字，统计每组的数字总和

  dfs时 第i层为第i个数字的分配情况

  所以时间复杂度为 O（k^n) （k为bucket数， n为分配的数字总数）

- 剪枝：

  - 大剪枝（预先判断）

    ① nums总数小于k

    ② 总和sum不能整除k（整除为均分的必要条件）

    ③最大的数字 > part

  - 剪枝1

    第一个数字只能分配在第一个bucket中，因为与其他时候等效

    所以这一层的时间复杂度变为1

    O(k^n) ----> O (k^(n-1))

  - 剪枝2

    如果此bucket 与 前一个bucket一样大小，那么会出现重复情况，则不必要此分支，故可以剪枝

    ```c++
    if(i && bucket[i] == bucket[i-1])continue;
    ```

  - 剪枝3

    可行性剪枝：  当此bucket中不能装下此number时也continue

    ```c++
    if(bucket[i] + nums[idx] > part)continue;
    ```

  ```c++
  vector<int> buckets;
      int part; //每个桶的最大容量
      bool canPartitionKSubsets(vector<int>& nums, int k) {
          buckets.resize(k);
          sort(nums.begin(),nums.end(),greater<int>());
          int sum = accumulate(nums.begin(), nums.end(), 0);
          part = sum / k;
          if(sum % k || nums.size() < k || nums[0] > part)return 0;
          if(dfs(nums,buckets,0))return 1;
          return 0;
      }
      bool dfs(vector<int> &nums, vector<int> & buckets, int idx){
          if(idx == nums.size())return 1;
          for(int i = 0 ;i < buckets.size(); i++){
              if(idx == 0 && i)break;
              if(i && buckets[i] == buckets[i-1])continue;
              int sum = buckets[i] + nums[idx];
              if(sum > part)continue;
              buckets[i] += nums[idx];
              if(dfs(nums, buckets, idx + 1))return 1;
              buckets[i] -= nums[idx];
          }
          return 0;
      }
  ```

  

# 13.greedy

无记忆性，每次处理达到局部最优，从而到达全局最优

证明贪心算法可行：利用反证法，（or数学归纳）

面试中不需要证明，只需要自圆其说就可以



## 13.0 解题步骤

* 分解为子问题
* 找出贪心策略 --> 局部最优解
* 将局部最优解 叠加 到全局最优解

## 13.1 Week1;

376.摆动序列

局部最优：删除单调坡度上的节点

实际上只需要做到记录峰的数量 +1 就可以了

贪心在不需要做到删除就可以统计出结果。

做法：

ｃｏｎｔｉｎｕｅ一直递增或递减的元素；

当碰到转折了再进行处理

特殊情况：

之前的坡度为０；

```ｃ++
 int wiggleMaxLength(vector<int>& nums) {
        if(nums.size()<=1)return nums.size();
        int n =nums.size();
        int ans = 1, curdiff = 0,prediff = 0;
        for(int i =1;i<n;i++){
            curdiff = nums[i] - nums[i-1];
            if(prediff<=0&&curdiff>0 || prediff>=0&&curdiff<0){
                ans++;
                prediff = curdiff;
            }
        }
        return ans;
```

或者ｄｐ法：

ｕｐ　和ｄｏｗｎ　数组储存到ｉ为止的最大长度　



53：最大连续子串的和

局部最优解： 当前的连续和>0   否则则重新从该数开始计算

​							作用：不能让前数之和＋该数后反而小于该数；

## 13.2 Week2

1.跳跃游戏

贪心：每次都取到能到达的最远距离、

cover = max(cover,nums[i]+i);

2.跳跃游戏2

贪心：每次取  当前可到达的最远距离   

​            每到最远距离后，即更新。

3.买卖股票2：

贪心：分解每次买卖为

```c++
假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。

相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。
      prices[3] +（- prices[2] + (prices[2]）+（ - prices[1] + prices[1]） - prices[0]。
       
```

每天只收集正利润 

```c++
for(int i = 1;i < prices.size();i++){         
        if (prices[i] < in_hand)
            in_hand = prices[i];  

        else if (prices[i] > in_hand)
        {  
            ans += prices[i] - in_hand;
            in_hand = prices[i];
        } 
    }            
//ji
for(int i = 1; i<prices.size();i++){
            if(in_handed > prices[i]){
                in_handed = prices[i];
            }
            if(in_handed  < prices[i] -fee){
                ans += prices[i] -fee - in_handed; 
                in_handed = prices[i] - fee;
            }
            
        }
```

4.K次取反 后最大值

贪心思想：将绝对值大的数字都变成整数 且按照大小优先级变换

```c++
sort(nums.)
```

## 13.3 Week3

1.加油站

有gas和cost2个vector，返回能能从该点出发绕一圈的 点 否则返回-1

局部最优：

rest[j]之前的前缀和 <0 那么就从j+1开始记录 cursum 归零 （因为前面已经无法绕完一圈了）

<img src="https://pic.leetcode-cn.com/98ee6782654518e1a33852e99825f1537869a542ee26738cf02d5fb6f0f0a899-%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题.png" style="zoom:50%;" />

把折线最低端提升 到全部都位于x轴上即可，此时对应最低点就是出发点

就是找到最低点minindex 再更新minvalue即可

其实跟上面的代码处理一致（如果cursum<0  重新计算 如果后面还小于0 就更新 也是找最小值）



2.分发糖果

**从2个维度限制的  只能先从一个维度出发处理 再处理另一个维度**

每个人最少给1个糖果，相邻2个小孩，分数高的糖果更多，问最少糖果是多少

先初始化结果数组，初始值为1；

从1开始遍历，与左边的值比较，如果大的话则+1（此处的贪心）

从后往前遍历 与右边值比较，如果大的话选择 max(右边值+1，self)；

关键 **max** 保证了2个条件同时满足

而后统计数组之和就好





3.根据身高重建队列

2个维度 ①身高 ②队列比自己高的数目

上面第二题一样  先从一个维度出发，因为②也依赖①存在，所以先从①入手

先将队列按照身高排序

再从底部（最高的） 元素贪心到能排到的最靠前的位置（因为不影响后面的判断）。

**一些优化**

在本题中会用到vector的insert用法 但是vector的insert复杂度为O（N） 所以总和代码的复杂度为O（N^2)

而在实际上复杂度还可能更大，因为在vector中 insert如果size超过了capacity 就会再申请2倍capacity的内存再一个一个复制过去。

所以复杂度为O(N^2 +t * n) 其中t 为复制的次数

而利用list 就可以很好的避免这个问题  

```c++
// 版本二，使用list（链表）
class Solution {
public:
    // 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector<int> a, const vector<int> b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1]; // 插入到下标为position的位置
            std::list<vector<int>>::iterator it = que.begin();
            while (position--) { // 寻找在插入位置
                it++;
            }
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
};
```

## 13.4 区间问题

452用最小数量的间打破气球

**让区间更聚集向一边：**

找共同区间问题，第一步：先排序； 第二部遍历处理

①以begin（）作为参考值排序， 则从前到后遍历

②以end（）作为参考值，则从后到前遍历

（为了让区间更紧凑地靠向一边）

处理过程就不断更新rmost 即可

```c++
sort...
int ans = 1, rmost = points[0][1];
for(int i = 1;....){
	if(rmost < point[i][0]){
	ans++;
	rmost = point[i][1];
	}
	else
		rmost = min(point[i][1],rmost);
}
```

435.无重叠区间

让区间重合度更低 

①以end（）作为参考值排序， 则从前到后遍历

这样留给右边的空间就大了

②以begin（）作为参考值，则从后到前遍历

这样留给左边的空间就大了

此时采用的是第①种方法， 记录存在最多多少个 不重合区间。

最后用size - 区间数目 就得到该去除的区间数目了

```c++
class Solution {
public:
    static bool cmp(vector<int> &a, vector<int> &b){
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end(),cmp);
        int ans = 1, rmost = intervals[0][1];
        for(int i =1;i<intervals.size();i++){
            if(rmost <= intervals[i][0]){
                ans++;
                rmost = intervals[i][1];
            }
        }
        return intervals.size()-ans;
    }
};
```

736.划分字母区间

先统计每个字母出现的最晚下标。

再根据下标划分区域

![763.划分字母区间](https://camo.githubusercontent.com/df42dd4499b985d072029c73d8a1923dca4890265806f9cea3781f7192ea0908/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313232323139313932343431372e706e67)

## 13.5 下一个排列

我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
	我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
在尽可能靠右的低位进行交换，需要从后向前查找
	将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列



# 14.dp

总结：

* 方法论

  - 前置的条件判断  以 解决dp中所无法解决的边界问题 或者在得到dp数据的过程中所会发生的错误

    * int 型除法取整问题  如果此时会有小数点后的数字那么会不会影响到结果的判断

      [目标和](https://leetcode-cn.com/problems/target-sum/submissions/)中则出现了这个问题

    * 是否会超出判断边界 

      分割等和子集中出现了这个问题  （官方解法，找出maxn 以及sum  与 sum/2的关系）

      

  - 定义dp数组

  - 传递方程

    如果是dp(i,j)

    必须考虑完全 ，从0 - i  每一层

    层内 from 0 to j 分类讨论

    （须从定义出发）

  - 初始化

    初始化实际考虑的是2个

    ①万物的遍历是从哪里开始的 

    ②所有边界的处理

  - 思考遍历顺序（根据dp传递方程 在 实际模拟图中的演习 得出）

    比如dp（i，j）是来源于左 上 则一般的正向遍历即可

    如果右，下 则 均反向遍历

* 可能的优化

  * 滚动数组

    ①降维的优化 可以优化空间复杂度 但是需要注意遍历顺序 和 数组此时的定义

     （比如在0/1背包问题中 需要反向遍历）、

    （此时问题是从定义上来的  ，  因为不能带有这一层的物品 ，所以必须反向遍历 才能避免）

    

    ②数组定义上不降维 但是 大小会是常数， 比如dp[i,j] - >dp[2, j];

    ​	此时可以在 第一维上做一个 i % 2 的处理 

    ​	还是可以将复杂度下降一个维度

  * 优化中注意的问题
  
    比如优化降维空间复杂度时 
  
    注意如下几点 	
  
    * 初始化数组
  
    * 遍历顺序 根据dp遍历图  以及 是否会影响到 （参考）数据来决定
  
    * 每层遍历时 是否需要在递推公式之外再进行某些处理
  
      （比如每层本来的初始化 数据）
  
      检查每层是否遍历完全每个数据  如果没有看看是否需要进行某些处理
  
      
  
    * 对某些无法储存到数组内的数据进行变量的储存
  
    * return 的值的变化



定义dp定义



## 14.1 week1

62 不同路径

递归公式 dp(i,j) = dp(i-1,j) +dp(i,j-1);

初始化 吧所有带有0的dp数组值化为1

递归从1开始即可

```c++
 int uniquePaths(int m, int n) {
        int dp[n];
        for(int i = 0; i < n; i++)dp[i] = 1;
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++){
                dp[j] = dp[j] + dp[j-1];
            }
            return dp[n-1];
    }
//优化为一维数组版本，因为传递公式 之和上和左有关 所以可以单位数组， + 左到右遍历
```

63不同路径2

不同在于：有obstacles 在此处许区别更新dp数组

比如 在边界处 在碰到obstacles 时 后面所有的都到达不了，所以均为0

而在一般地点的obstacles 就简单更新为0 周围不受影响就行了。 



343 整数拆分

（剑指割绳子问题）‘

dp做法

观察到 要求将 子绳子再割 和 只保留子绳子本身长度  来进行乘法 

而我们通过基本不等式得到 分割后的最大乘积为 (n/2) *(n/2) 与 n 比较得到4 为分界点

即4以前的 保留原绳子长度 4以后的 在进行进一步分割找到最大值

```c++
//法一 dp
dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        for(int i = 4; i <= n; i++){
            int maxn = 1;
            for(int j = 1; j <= i/2; j++){
                maxn = max(maxn, dp[j] * dp[i-j]);
        }
        dp[i] = maxn;
        }
        return dp[n];
//法二 贪心
//下面证明合理性
```

贪心合理性： 

①每次c拆分因子相等， ②拆分最优为3 次优为2；

① 由数论得基本不等式得  (x1 * x2 * x3 * .. * xn)^(1 / a) <= (x1 + x2 + x3 + ... + xn) / n;

所以可知再x 取都相等得情况下最大

②用微分知识解决

<img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220420101405893.png" alt="image-20220420101405893" style="zoom:50%;" /> 

BST 的种类

算是二刷，但是有点忘记了递归公式

从1、2个节点到3个节点的演化：

①个节点 只有1 中情况  ②个节点有 2种情况，

③ 个节点 ： 把root 单独隔离开，  看左 右子树的组合关系确认递归公式：



0 + 2 ； 1 + 1; 2 + 0;

所以就是上述三种情况  0 对应1 种 1 对应 1 种 2 对应 2种情况 所以最后相加起来就是5种情况

```c++
if(n <= 2) return n;
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++){
            for(int j = 0; j <i;j++){
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
```

## 14.2背包问题

![416.分割等和子集1](https://camo.githubusercontent.com/5c5af3f54a3503cdb989ab1c28e2933202a33259608c70af0e72db5a858f14e6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303131373137313330373430372e706e67)

### ①0/1背包问题

dp(i,j) 此时的最大在容量 为j ，前i 个物品中选取 可容纳的最大价值

传递方程：

dp(i,j ) = max(dp(i,j) , dp(i-1, j - weight[j]) + value[j])；

全设为0

遍历顺序 正向



1.为什么两个for循环的嵌套顺序这么写？

​	先遍历物品顺序 （即：在前i个物品中选取）再遍历背包容量（即：在最大背包容量为j的情况下）所能容纳的最大value

2.反过来写行不行？再讲一讲初始化的逻辑。

​	也可以，意思是在背包容量为j的情况下，在前i个物品中选取，在数组图形化展示中 也就是先行列更新和列行更新的区别

​	如果题目给的价值有负数，那么非0下标就要初始化为负无穷。

​	初始化时就是一样  全为0 即可

​	区别就是会比较慢在遍历上

3.然后要求实现一个一维数组的01背包，

​	因为只和左和上有关系 所以是可以成立的，但是循环的顺序就变成 逆序遍历，in case that 每次更新时的

dp(i,j - w[i]) 为更新后的状态  所以只能往左更新。

4.最后再问，一维数组的01背包，两个for循环的顺序反过来写行不行？为什么？

​	不行，因为此时是按照背包容量-物品下标的顺序来更新，而按照刚刚说得的 只能从后往前更新容量，

​	因为我们返回的值是最大容量时候的值 而更新这个值的时间在第一次遍历就已经完成，此时只放入了一个物品，并不能保证最大

```c++
	for(int i = 1; i <= m; i ++)
        for(int j = 1; j <= n; j++){
            if(j > w[i-1]) dp[i][j] = dp[i-1][j];
            else{
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i-1]] + v[i-1]);
            }
            return dp[m][n];
        }
	for(int i = 0; i < n; i++)
        for(int j = volumn; j >= nums[i]; j--){
            dp[j] = max(dp[j], dp[j-nums[i]] + value[i]);
        }
```

①分割等和子集

化为背包问题 容量变成 总和sum 的1/2 倍，然后每个物品的value and volume 都是nums[i] 

其他一致

sum = sum/2;

最后返回 dp[sum] == sum 即可 即是否可以在容量为sum/2 背包里放下sum/2 的物质



②最后一块石头的重量2 

跟①题目一样 找到sum/2 的容量下的最大包含重量  然后与剩下的相减 即可得到最小的数量

#### 组合问题

③目标和 **组合问题**

可以用backtrack 但是时间复杂度是 dp的指数倍

注意在前置的判断中 

* pos是否存在的判断
* target 是否可行的判断

dp[j] 表示在j的容量下可以含有的最多组合个数

​	初始化 

dp[0] = 1;

和为0 情况下只有一种情况就是 不选

​	传递公式

dp[j] += dp[j - nums[i]]; 因为此时表示的不是最大和（即价值）  所以只用表示组合个数就行



#### 二维 0/1 背包

④一和零

此时是求最大容量  每个物品的value 为 1  weight 为二维变量 为即0 和 1 的个数

此时还是逆序遍历

```c++
dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);
```

### ②完全背包问题

此时变化为任一物品的可选数量为无限个

与0/1 背包不同的是，此时可以添加多次  所以在一维数组优化中 可以从小到达遍历 而不用逆序遍历

```c++
for(int i = 0; i < weight.size(); i++)
    for(int j = weight[i]; j <= bagWeight; j++){
        dp[j] = max(dp[j], dp[j - weight[i] + value[i]]);
    }
```

#### 完全背包求最小组合数

①零钱兑换1 求成立的组合中 用量最小的

求最小值 相当于 weight为coins  value 为 1；

​	初始化 

```c++
vector<int> dp(amount + 1, amount + 1);
dp[0] = 0;//意味着总和为 0 的数 用0个东西组成就够了
```

​	传递公式

```
dp[j] = min(dp[j], dp[j - coins[i]] + 1);
```

#### 完全背包组合问题

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

①零钱兑换2 求能拥有的最大组合数

跟0/1 背包中组合问题相似 但是区别在于 不用逆序遍历

​	初始化

dp[0] = 1;

​	传递公式

```c++
 for(int i = 0; i < n; i++)
            for(int j = coins[i]; j <= amount; j++){
                dp[j] += dp[j - coins[i]];
            }
```

**求排列数**

爬楼梯进阶

组合总和iV

### ③多重背包问题

法1：将多重背包中的 个数 > 1 的物品 逐个push_back value 和weght 到对应数组中  并num -- 

​	构造0/1 背包

法2：三层循环 前2层位01背包 再加一层k循环（循环个数）

```c++
for(int i = 0; i < n; i++)
    	for(int j = bagWeight; j >= weight[i]; j--)
        {
            for(int k = 1; k <= nums[i] && k * weight[i] <= j; k++){
                dp[j] = max(dp[j], dp[j - weight[i] * k] + k*v)
            }
        }
```



## 14.3最大子序列

定义区分： 

子数组： 必须是连续的元素组成的元组

子序列： 可以是分开的元素组成的元组 子序列 包含 子数组

### 子序列问题

1、

[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

定义：dp[i] 以nums[i] 结尾的递增序列最长长度

传递公式： dp[i] = max(dp[i] , dp[j] + 1);

遍历顺序： 从左到右  后 从i -1 到0

初始化： 因为可以是从自己开始 所以全部可以初始化为1；



2、

[最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

定义： dp（i， j)  在（0， i-1）（0，j-1）中最长的公共序列

传递公式：

a = s[i] , b = t[i] 2个字符  有一下4中情况；

a != b:

00啥也不包含 此时最小

10严格包含a 但是不一定最长序列中有a

01严格包含b 但是不一定最长序列中有b ‘

dp(i,j) = max(dp(i-1, j), dp(i, j-1));

a == b:

11都选中的情况就是当 a == b 时， 最长公共序列可以在dp(i-1, j-1) + 1;

else 就是取最大值

初始化： dp(i,0) = 0, dp[0, j] =0;

遍历顺序：从上面地递推公式可以看出  dp(i,j)从左边上面得到， 所以正序遍历 为了快捷先i 后j

[不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/) 与此为同一题 仅仅具象化了而已



3、

[判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

定义： dp(i, j) : （0, i-1) (0, j-1) 的最大公共子序列  

传递公式：

s 为 子序列  t 为母序列

a == s[i-1] b = t[j-1]

if a ==b :

dp(i , j) = dp(i-1, j -1) + 1;

else:

把b 去掉继续向下匹配  

即dp(i, j) = dp(i, j -1)  

初始化：

由定义： dp(i ,0) dp(0 j ) =0



4、

不同的子序列

​	定义

dp(i, j) :(0, i-1) (0,j-1) 的最多匹配种类

​	传递方程：

s(i-1) 为 母字符串， t(j-1) 为子字符串

a == b :

dp(i ,j ) = dp(i -1)(j ) + dp(i-1,j-1) 

（① 不利用 a 来组成最长子字符串 ② 利用a）

a! =b:

dp(i,j) = dp(i , j-1) ;

因为不相等 所以只能是 不用a来组成

​	初始化：

dp(0,j) = 1;

定义 ： 为删除了j个字符后可得到空字符串。 但是只有一种方法 所以 为1；

其余为0

* 优化 直接降维 为1 维数组 注意初始化和转移方程的公式 和 遍历的顺序  以及 每层是否要更新；

### 子数组问题

1.最长重复子数组

* 定义 

  dp(i,j) 第一个数组前i 第二个数组前j 个中的有的最多重复字符；

* 传递方程

  ```c++
  if(s[i] == t[j]){
      dp[i][j] = dp[i-1][j-1] + 1;
  }
  else{
      dp[i][j] = 0;
  }
  ```

* 初始化

  ```c++
  dp[i][0] = 0;
  dp[j][0] = 0;
  //全部遍历一边
  ```

* 遍历顺序

  需要从1 开始 到m 结束  ---第一层

  从1 开始到n 借书   --- 第二层

### 编辑问题

1.字符串删除操作

* 定义

  dp(i,j) 表示前i j 个字符中的最小删除操作 

* 传递方程

  ```
  if == 
  dp[i][j] = dp[i-1][j-1];
  else{
  dp[i][j] = min(dp[i-1][j] + 1, dp[i-1][j-1] + 2, dp[i][j-1] + 1);
  }
  ```

  

* 初始化

  dp(i,0) = i; dp(0,j) = j;

2.编辑问题

与1一致 剩余变化在传递方程

```
if == 
dp[i][j] = dp[i-1][j-1];
else{
dp[i][j] = min(dp[i-1][j] + 1, dp[i-1][j-1] + 1, dp[i][j-1] + 1);
}
```

### 回文问题

1.回文子串

- 定义

  dp(i,j)为从（i，j）的子串是否为回文子串 类型为bool

- 传递方程

  ```c++
  if(i == j) dp[j][i] = 1;
  else if (s[i] == s[j] && (j == i-1 || dp[j+1][i-1]))//注意且和或的优先级不同
  	dp[j][i] = 1;
  if(dp[j][i]) ans++;
  ```

  

- 初始化

  全部为0

- 优化

  空间降维到O（n）

  由上面地推公式看出  只跟 i-1 层有关 所以可以忽略其他层 直接降维

  ```c++
  //全部初始化为0
  for(int i = 0; i < n; i++){
              for(int j = 0; j <= i; j++){
                 if(i == j){
                     dp[j] = 1;
                     ans++;
                 }
                  else if(s[i] == s[j] && (dp[j+1] || j == i-1)){//且和或的优先级不同
                      dp[j] = 1;
                      ans++;
                  }
                  else dp[j] = 0;//因为是一层 所以注意要归为0 的更新
              }
          }
  ```

2.最长回文子序列

- 定义

  dp(i，j）中最长的子序列数目

- 传递方程

  ```c++
  if(i == j){
      dp[j][i] = 1;
  }
  else if(s[i]== s[j]){
      dp[j][i] = dp[j+1][i-1] + 2;//因为j+1 > i-1 时为0 所以 + 2 也符合
  }
  ```

- 初始化

  全部为0

- 优化

  优化为一维的数组

  经过观察和画图 dp(j,i)只和下面和左边以及左下边的值有关

  所以遍历时保存住左下角的值即可

  ```c++
   for(int i = 0; i < n; i++){
              int old = 0;
              int temp = 0;
              for(int j = i; j >=0 ; j--){
                  temp = dp[j];
                  if(i == j){
                      dp[j] = 1;
                  }
                  else if(s[i] == s[j]){
                      if(j == i-1){
                          dp[j] = 2;
                      }
                      else{
                          dp[j]= old+ 2;
                      }
                  }
                  else dp[j] = max(dp[j+1], dp[j]);
                  old = temp;
              }
          }
  ```

  

## 14.4 股票系列

### 1.stockⅡ

- dp定义：

  dp(i,0) dp(i,1) :0 代表此时不持有股票 1 代表此时持有股票

  dp代表的是此状态下的最大持有金额

- 传递方程

  ```c++
   dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
   dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
  ```

- 初始化

  由上述2个式子 看出 跟最初的dp(0,0) dp(0,1)有关 根据定义初始化这2个值即可

- 遍历顺序

  正序

- 优化

  降维为滚动的二维数组dp(2,2);

  

### 2.stockⅢ

* dp定义

  1-4为2次购买状态 买or卖；

* 传递方程

  简单比较max

* **初始化**

  ```c++
  dp[0][1] = -prices[0];
  dp[0][2] = 0;//卖出的最大金额就是prices[0] - prices[0] = 0;
  dp[0][3] = -prices[0]; //相当于当天买一次卖一次 再继续买入
  dp[0][4] = 0;//与dp[0][2] 一致
  ```

* 遍历顺序‘

  正序

### 3.stockⅣ

与上一题基本一致

多一个前置的判断 n == 0 || k == 0 return 0;



### 4.含冷冻期的stock

* dp定义

  3个状态 0 买入 1 卖出 2 冷冻期

* 转移方程

  ```c++
   dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i]);
              dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
              dp[i][2] = dp[i-1][1];
  ```

* 初始化



### 5.含手续费的stock

转移方程

```c++
 dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);
```

初始化

//0 持有股票时拥有的最大金额  1 不持有股票时拥有的最大金额

dp(0,0) = -prices[0];

dp(0,1) = 0; //因为此时最划算就是如此  

# 15.bit calculaiton

0x55555555 取奇数位的数字

0xaaaaaaaa  ------偶数位

- 利用或操作|转换位小写

  ```
  ('a' | ' ') == 'a';
  ('A' | ' ') == 'a';
  ```

- 利用与和下划线转化为大写

  ```
  ('b' & '_') = 'B'
  ('B' & '_') = 'B'
  ```

- 利用抑或和空格惊醒大小写的切换

  ```
  ('d' ^ ' ') = 'D‘
  ('D' ^ ' ') = 'd'
  ```

- 不用临时变量进行交换2个数字

  ```c++
  void swap(int &a, int &b){
  	a ^= b;
      b ^= a;
      a ^= b;
  }
  ```

- n &=  (n - 1)

  作用： 消除最后一个1 

  可以利用来计算1 的个数

  或者还有lowbit 来算更直观

- 求n的第k位数字

  ```
  n >> 1 & 1
  ```

  

# 16.前缀和

关键词： 连续子数组  和 （sum）

[和韦K的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```c++
int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> freq;
        freq[0] = 1;
        int sum = 0, ans = 0;
        for(int &i : nums){
            sum += i;
            ans += freq[sum - k];
            freq[sum] ++;
        }
        return ans;
    }
```

此时利用unordered_map也可以以空间换时间

利用O（N）的空间 换取时间复杂度降维 N 的一次放方

k - sum 意味着 如果前面存在着这么大的前缀和  那么就 能通过freq 哈希表 找到对应的出现频次  并加到ans 上  

具体比较像 **两数之和**



相同01数目；https://leetcode.cn/problems/contiguous-array/

- 思路

  一样是前缀和， 但是没有unordered_map<pari<int,int>int> 

  由题意优化为 利用<sum,index>的map

  sum碰到0 则-1 碰到 1 则 + 1. index 存储满足情况的最小index

  则相同的sum 0 1 偏差值一样，  index_cur - map[sum] 即是答案

  （此时需要预处理， map[0] = -1);



按权重随机选择https://leetcode.cn/problems/random-pick-with-weight/

用presum数组使得随机数rdn 满足 满足pre[i]<= rdn < pre[i+1]; 返回 i即可

(所以前面需要一个presum[0] = 0)

可以用收缩r（向左收缩）的方法， 条件为presum[mid] > rdn

或者收缩 条件为 presum[mid] <= rdn

# 图

①indegree 配合 bfs 真的好用

# 差分数组

<img src="C:\Users\22470\AppData\Roaming\Typora\typora-user-images\image-20220821014345991.png" alt="image-20220821014345991" style="zoom: 40%;" />

```c++
class Solution {
public:
    string shiftingLetters(string s, vector<vector<int>>& shifts) {
        int n = s.size();
        vector<int> f(n + 1);
        for (auto &vec : shifts) {
            if (vec[2] == 1) f[vec[0]]++, f[vec[1] + 1]--;
            else f[vec[0]]--, f[vec[1] + 1]++;
        }
        string ans;
        for (int i = 0, delta = 0; i < n; i++) {
            int c = s[i] - 'a';
            delta += f[i];
            c = ((c + delta) % 26 + 26) % 26;
            ans.push_back(c + 'a');
        }
        return ans;
    }
};

```

